<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Duel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow-y: auto;
        }
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            border: 3px solid #1f2937;
            width: 100%;
            height: 100%;
            max-width: 450px;
            max-height: 450px;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            background-color: #1f2937;
            gap: 1px;
        }
        .sudoku-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #d1d5db;
            font-size: clamp(0.8rem, 4vw, 1.25rem);
            position: relative;
            background-color: #fff;
            font-weight: 600;
        }
        /* 3x3 subgrid borders */
        /* Corrected selectors for vertical borders */
        .sudoku-cell:nth-child(9n-6),
        .sudoku-cell:nth-child(9n-3) {
            border-right: 3px solid #1f2937;
        }

        /* Corrected selectors for horizontal borders */
        .sudoku-grid > .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-grid > .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 3px solid #1f2937;
        }

        .player-cell-owner-1 { background-color: rgba(239, 68, 68, 0.1); } /* red-100 */
        .player-cell-owner-2 { background-color: rgba(59, 130, 246, 0.1); } /* blue-100 */
        
        .selected-cell {
            background-color: #fef9c3; /* yellow-100 */
            outline: 2px solid #f59e0b; /* amber-500 */
            z-index: 10;
        }
        .original-number { font-weight: 700; color: #1f2937; }
        .player-number { color: #3b82f6; }
        .incorrect-number { color: #ef4444; text-decoration: line-through; }

        .modal {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }
        .turn-indicator {
            transition: all 0.3s ease-in-out;
        }
        .timer-warning {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .cell-highlight {
            background-color: #fef3c7 !important;
            box-shadow: 0 0 0 2px #f59e0b;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-2 sm:p-4">

    <div id="app" class="w-full h-full max-w-4xl mx-auto p-2 sm:p-4 flex flex-col items-center justify-center">

            <!-- Score Display -->
            <div id="score-display" class="hidden w-full max-w-4xl mx-auto mb-4">
                <div class="bg-white rounded-lg shadow-md p-4">
                    <h3 class="text-lg font-bold text-center mb-3">Score Board</h3>
                    <div class="flex justify-between items-center">
                        <div class="text-center">
                            <div class="text-sm text-gray-600">Player 1 Wins</div>
                            <div id="p1-wins" class="text-2xl font-bold text-red-600">0</div>
                        </div>
                        <div class="text-center">
                            <div class="text-sm text-gray-600">Draws</div>
                            <div id="draws" class="text-2xl font-bold text-gray-600">0</div>
                        </div>
                        <div class="text-center">
                            <div class="text-sm text-gray-600">Player 2 Wins</div>
                            <div id="p2-wins" class="text-2xl font-bold text-blue-600">0</div>
                        </div>
                    </div>
                    <div class="mt-3 text-center">
                        <button id="reset-scores-btn" class="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition">Reset Scores</button>
                    </div>
                </div>
            </div>

        <!-- Game Area -->
        <div id="game-area" class="hidden w-full flex flex-col items-center justify-center space-y-2 sm:space-y-4">
            <!-- Player Info and Timers -->
            <div class="w-full flex flex-col md:flex-row gap-4 items-center">
                <!-- Player 1 -->
                <div id="player1-panel" class="p-4 bg-white rounded-lg shadow-md border-4 border-transparent w-full md:flex-1 order-2 md:order-1">
                    <h2 class="text-xl font-bold text-center text-red-600">Player 1 <span id="player1-id" class="text-xs text-gray-500 font-mono"></span></h2>
                    <div id="timer1" class="text-4xl font-mono font-bold text-center my-2">00</div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="progress1" class="bg-red-500 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                </div>

                <!-- Game Info -->
                <div class="text-center order-1 md:order-2">
                     <h1 class="text-2xl sm:text-3xl font-bold text-gray-700">Sudoku Duel</h1>
                     <div class="flex items-center justify-center space-x-2 mt-1">
                        <p id="game-id-display" class="font-mono text-sm text-gray-500"></p>
                        <button id="copy-game-id-btn" class="hidden p-1 bg-gray-200 rounded-md hover:bg-gray-300 transition" title="Copy Game ID">
                            <svg id="copy-icon" class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                            <svg id="check-icon" class="w-4 h-4 text-green-600 hidden" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>
                        </button>
                    </div>
                     <button id="end-game-btn" class="mt-2 px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">End Game</button>
                </div>

                <!-- Player 2 -->
                <div id="player2-panel" class="p-4 bg-white rounded-lg shadow-md border-4 border-transparent w-full md:flex-1 order-3">
                    <h2 class="text-xl font-bold text-center text-blue-600">Player 2 <span id="player2-id" class="text-xs text-gray-500 font-mono"></span></h2>
                    <div id="timer2" class="text-4xl font-mono font-bold text-center my-2">00</div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="progress2" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                    <div id="ai-thinking" class="hidden text-center mt-2">
                        <div class="inline-flex items-center text-blue-600">
                            <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600 mr-2"></div>
                            <span class="text-sm">AI is thinking...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sudoku Board -->
            <div class="bg-white p-2 sm:p-4 rounded-lg shadow-lg w-full max-w-sm sm:max-w-md mx-auto">
                <div id="sudoku-board" class="sudoku-grid">
                        <!-- Cells will be generated by JS -->
                </div>
            </div>

            <!-- Number Pad -->
            <div id="number-pad" class="flex flex-wrap justify-center gap-2 mt-4">
                <!-- Numbers 1-9 and Erase button generated by JS -->
            </div>
        </div>

        <!-- Setup Modal -->
        <div id="setup-modal" class="modal fixed inset-0 flex items-center justify-center z-50">
            <div class="bg-white p-8 rounded-lg shadow-2xl w-full max-w-md text-center">
                <h1 class="text-3xl font-bold mb-6">Sudoku Duel</h1>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Game Mode</label>
                    <div class="flex justify-center space-x-2">
                        <button id="vs-ai-btn" class="mode-btn flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg">vs. AI</button>
                        <button id="vs-player-btn" class="mode-btn flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg">vs. Player</button>
                    </div>
                </div>

                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Difficulty</label>
                    <div class="flex justify-center space-x-2">
                        <button class="difficulty-btn flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg" data-difficulty="easy">Easy</button>
                        <button class="difficulty-btn flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg" data-difficulty="medium">Medium</button>
                        <button class="difficulty-btn flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg" data-difficulty="hard">Hard</button>
                    </div>
                </div>

                <div class="mb-6">
                    <label for="timer-select" class="block text-sm font-medium text-gray-700 mb-2">Turn Time (seconds)</label>
                    <select id="timer-select" class="w-full p-2 border border-gray-300 rounded-lg">
                        <option value="15">15</option>
                        <option value="30" selected>30</option>
                        <option value="45">45</option>
                        <option value="60">60</option>
                    </select>
                </div>

                <div class="mb-6">
                    <div class="bg-green-50 border border-green-200 rounded-lg p-3">
                        <div class="flex items-center">
                            <svg class="w-5 h-5 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-green-700 font-medium">Online Mode Ready</span>
                        </div>
                        <p class="text-xs text-green-600 mt-1">Firebase & Gemini AI are configured!</p>
                        <p class="text-xs text-gray-500 mt-1">Check browser console for status</p>
                    </div>
                </div>
                
                <div id="multiplayer-options" class="hidden">
                    <button id="create-game-btn" class="w-full mb-4 px-4 py-3 bg-green-500 text-white font-bold rounded-lg hover:bg-green-600 transition">Create Game</button>
                    <div class="flex items-center space-x-2">
                        <input type="text" id="join-game-id" placeholder="Enter Game ID" class="flex-grow p-2 border border-gray-300 rounded-lg">
                        <button id="join-game-btn" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600">Join</button>
                    </div>
                </div>

                <button id="start-ai-game-btn" class="w-full px-4 py-3 bg-green-500 text-white font-bold rounded-lg hover:bg-green-600 transition">Start Game</button>
            </div>
        </div>
        
        <!-- Message Modal -->
        <div id="message-modal" class="hidden modal fixed inset-0 flex items-center justify-center z-50">
             <div class="bg-white p-8 rounded-lg shadow-2xl w-full max-w-sm text-center">
                <h2 id="message-title" class="text-2xl font-bold mb-4">Game Over</h2>
                <p id="message-text" class="mb-6">Player 1 wins!</p>
                <button id="message-close-btn" class="w-full px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600">Play Again</button>
            </div>
        </div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- DOM ELEMENTS ---
        const gameArea = document.getElementById('game-area');
        const setupModal = document.getElementById('setup-modal');
        const messageModal = document.getElementById('message-modal');
        const sudokuBoard = document.getElementById('sudoku-board');
        const numberPad = document.getElementById('number-pad');
        
        // --- STATE VARIABLES ---
        let db, auth, app;
        let userId = null;
        let gameId = null;
        let currentGame = null;
        let localPlayerNumber = null;
        let selectedCell = null;
        let turnTimerInterval = null;
        let unsubscribeGame = null;
        let geminiApiKey = 'AIzaSyA_PNmd0OZ97_rgFj-lRcA-J95EbDF9wEA';
        let scores = { p1Wins: 0, p2Wins: 0, draws: 0 };
        
        // --- FIREBASE CONFIG (Provided by user) ---
        const firebaseConfig = {
            apiKey: "AIzaSyAlaBsrVByxdpNWyx8Z73tkZApfjOb9ngA",
            authDomain: "sudoku-2024.firebaseapp.com",
            projectId: "sudoku-2024",
            storageBucket: "sudoku-2024.appspot.com",
            messagingSenderId: "321897928553",
            appId: "1:321897928553:web:733c50de79054a0b28cff8"
        };
        const appId = 'sudoku-duel-online';


        // --- GEMINI API INTEGRATION ---
        async function callGeminiAPI(prompt) {
            if (!geminiApiKey) {
                console.warn('Gemini API Key is missing. Using fallback.');
                return null;
            }
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Gemini API request failed:', errorData);
                    return null;
                }

                const data = await response.json();
                
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    return data.candidates[0].content.parts[0].text;
                }
                console.warn('Gemini API response format unexpected, using fallback');
                return null;
            } catch (error) {
                console.error('Gemini API error:', error);
                console.warn('Using fallback due to API error');
                return null;
            }
        }

        async function testGeminiAPI() {
            try {
                const response = await callGeminiAPI("Say 'Hello, I am working!' and nothing else.");
                if (response) {
                    console.log('✅ Gemini API is working:', response);
                } else {
                    console.log('⚠️ Gemini API test failed, using fallback AI');
                }
            } catch (error) {
                console.log('⚠️ Gemini API test error:', error);
            }
        }

        async function getAIMove(gameData) {
            const board = Array(81).fill(0);
            for (let i = 0; i < 81; i++) {
                if (gameData.puzzle[i] !== 0) {
                    board[i] = gameData.puzzle[i];
                } else if (gameData.p1Cells[i] !== undefined && gameData.p1Cells[i] !== 0) {
                    board[i] = gameData.p1Cells[i];
                } else if (gameData.p2Cells[i] !== undefined && gameData.p2Cells[i] !== 0) {
                    board[i] = gameData.p2Cells[i];
                }
            }

            const prompt = `You are an expert Sudoku AI playing a competitive game. Your assigned cells are Player 2. Make the best possible move on this 9x9 Sudoku board. Return ONLY the move as "index:value". Example: "15:7".\n\nBOARD (0=empty):\n${board.join('')}`;
            const response = await callGeminiAPI(prompt);
            if (response) {
                const match = response.match(/(\d+):(\d+)/);
                if (match) {
                    const index = parseInt(match[1]);
                    const value = parseInt(match[2]);
                    if (gameData.p2Cells.hasOwnProperty(index) && value >= 1 && value <= 9) {
                        return { index, value };
                    }
                }
            }
            return getFallbackAIMove(gameData);
        }

        function getFallbackAIMove(gameData) {
            const aiCells = Object.keys(gameData.p2Cells);
            const unsolvedAiCells = aiCells.filter(cell => gameData.p2Cells[cell] === 0 || gameData.p2Cells[cell] !== gameData.solution[cell]);
            if (unsolvedAiCells.length > 0) {
                const cellToSolve = unsolvedAiCells[Math.floor(Math.random() * unsolvedAiCells.length)];
                const correctValue = gameData.solution[cellToSolve];
                return { index: parseInt(cellToSolve), value: correctValue };
            }
            return null;
        }

        // --- SUDOKU LOGIC ---
        const sudokuGenerator = {
             puzzles: {
                easy: [{ puzzle: "603000001000400000050070080000003000000295000000800000020050030000007000400000205", solution: "683924571192485367754371982875143629231695748946872153327519846518267493469738215" }],
                medium: [{ puzzle: "530070000600195000098000060800060003400803001700020006060000280000419005000080079", solution: "534678912672195348198342567859761423426853791713924856961537284287419635345286179" }],
                hard: [{ puzzle: "800000000003600000070090200050007000000045700000100030001000068008500010090000400", solution: "812753649943682175675491283154237896369845721287169435521974368438526917796318542" }]
            },
            generate: async function(difficulty = 'medium') {
                const prompt = `Generate a new 9x9 Sudoku puzzle with a '${difficulty}' difficulty. It must have a single unique solution. Return ONLY valid JSON with "puzzle" and "solution" keys, each an 81-character string.`;
                try {
                    const response = await callGeminiAPI(prompt);
                    if (response) {
                        const cleanedResponse = response.replace(/```json|```/g, '').trim();
                        const data = JSON.parse(cleanedResponse);
                        if (data.puzzle && data.solution && data.puzzle.length === 81 && data.solution.length === 81) {
                            console.log('✅ Generated new puzzle from Gemini AI.');
                            const puzzle = data.puzzle.split('').map(Number);
                            const solution = data.solution.split('').map(Number);
                            const { p1Cells, p2Cells } = this.assignCells(puzzle);
                            return { puzzle, solution, p1Cells, p2Cells };
                        }
                    }
                } catch (error) {
                    console.warn(`Gemini puzzle generation failed: ${error}. Using a fallback puzzle.`);
                }
                const fallback = this.puzzles[difficulty][0];
                const puzzle = fallback.puzzle.split('').map(Number);
                const solution = fallback.solution.split('').map(Number);
                const { p1Cells, p2Cells } = this.assignCells(puzzle);
                return { puzzle, solution, p1Cells, p2Cells };
            },
            assignCells: function(puzzle) {
                const emptyCells = [];
                for(let i=0; i<81; i++) if(puzzle[i] === 0) emptyCells.push(i);
                emptyCells.sort(() => Math.random() - 0.5);
                const p1Cells = {};
                const p2Cells = {};
                emptyCells.slice(0, Math.floor(emptyCells.length / 2)).forEach(i => p1Cells[i] = 0);
                emptyCells.slice(Math.floor(emptyCells.length / 2)).forEach(i => p2Cells[i] = 0);
                return { p1Cells, p2Cells };
            }
        };

        // --- UI RENDERING ---
        function renderBoard(game) {
            sudokuBoard.innerHTML = '';
            let isMyTurn = (game.turn === 'player1' && localPlayerNumber === 1) || (game.turn === 'player2' && localPlayerNumber === 2);
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.classList.add('sudoku-cell', 'cursor-pointer', 'transition-colors');
                cell.dataset.index = i;
                const isP1Cell = game.p1Cells.hasOwnProperty(i);
                const isP2Cell = game.p2Cells.hasOwnProperty(i);
                let cellValue = game.puzzle[i];
                let isOriginal = cellValue !== 0;
                if (isP1Cell && game.p1Cells[i] !== 0) cellValue = game.p1Cells[i];
                if (isP2Cell && game.p2Cells[i] !== 0) cellValue = game.p2Cells[i];
                if (cellValue !== 0) {
                    cell.textContent = cellValue;
                    if (isOriginal) cell.classList.add('original-number');
                    else {
                        cell.classList.add('player-number');
                        if(cellValue !== game.solution[i]) cell.classList.add('incorrect-number');
                    }
                }
                if (isMyTurn) {
                    if (localPlayerNumber === 1 && isP1Cell) cell.classList.add('player-cell-owner-1', 'hover:bg-red-200');
                    else if (localPlayerNumber === 2 && isP2Cell) cell.classList.add('player-cell-owner-2', 'hover:bg-blue-200');
                } else {
                    if (isP1Cell) cell.classList.add('player-cell-owner-1');
                    if (isP2Cell) cell.classList.add('player-cell-owner-2');
                }
                cell.addEventListener('click', () => handleCellClick(i));
                sudokuBoard.appendChild(cell);
            }
             if (selectedCell !== null) {
                const cellEl = sudokuBoard.querySelector(`[data-index='${selectedCell}']`);
                if (cellEl) cellEl.classList.add('selected-cell');
            }
        }

        function updateUI(game) {
            if (!game) return;
            currentGame = game;
            renderBoard(game);
            updateTimers(game);
            updateProgress(game);
            updateScoreDisplay();
            const p1Panel = document.getElementById('player1-panel');
            const p2Panel = document.getElementById('player2-panel');
            document.getElementById('player1-id').textContent = `(${game.p1.slice(0, 6)})`;
            document.getElementById('player2-id').textContent = game.p2 === 'AI' ? '(AI)' : (game.p2 ? `(${game.p2.slice(0, 6)})` : '...');
            p1Panel.classList.remove('border-red-500', 'border-blue-500');
            p2Panel.classList.remove('border-red-500', 'border-blue-500');
            if(game.status === 'active') {
                if (game.turn === 'player1') p1Panel.classList.add('border-red-500');
                else p2Panel.classList.add('border-blue-500');
            }
        }

        function updateScoreDisplay() {
            document.getElementById('p1-wins').textContent = scores.p1Wins;
            document.getElementById('p2-wins').textContent = scores.p2Wins;
            document.getElementById('draws').textContent = scores.draws;
        }

        function loadScores() {
            const savedScores = localStorage.getItem('sudoku-scores');
            if (savedScores) scores = JSON.parse(savedScores);
        }

        function saveScores() {
            localStorage.setItem('sudoku-scores', JSON.stringify(scores));
        }

        function updateScore(winner) {
            if (winner === 'player1') scores.p1Wins++;
            else if (winner === 'player2') scores.p2Wins++;
            else scores.draws++;
            saveScores();
            updateScoreDisplay();
        }

        function resetScores() {
            scores = { p1Wins: 0, p2Wins: 0, draws: 0 };
            saveScores();
            updateScoreDisplay();
        }
        
        function updateProgress(game) {
            const totalP1 = Object.keys(game.p1Cells).length;
            const filledP1 = totalP1 > 0 ? Object.values(game.p1Cells).filter((v, i) => v !== 0 && v === game.solution[Object.keys(game.p1Cells)[i]]).length : 0;
            document.getElementById('progress1').style.width = totalP1 > 0 ? `${(filledP1 / totalP1) * 100}%` : '0%';
            const totalP2 = Object.keys(game.p2Cells).length;
            const filledP2 = totalP2 > 0 ? Object.values(game.p2Cells).filter((v, i) => v !== 0 && v === game.solution[Object.keys(game.p2Cells)[i]]).length : 0;
            document.getElementById('progress2').style.width = totalP2 > 0 ? `${(filledP2 / totalP2) * 100}%` : '0%';
        }

        function updateTimers(game) {
            clearInterval(turnTimerInterval);
            const timer1El = document.getElementById('timer1');
            const timer2El = document.getElementById('timer2');
            if (game.status !== 'active') {
                timer1El.textContent = '00';
                timer2El.textContent = '00';
                return;
            }
            const update = () => {
                const remaining = Math.max(0, Math.ceil((game.turnEndTime - Date.now()) / 1000));
                const display = String(remaining).padStart(2, '0');
                if (game.turn === 'player1') {
                    timer1El.textContent = display;
                    timer2El.textContent = String(game.timerSetting).padStart(2, '0');
                    if (remaining <= 5) timer1El.classList.add('timer-warning'); else timer1El.classList.remove('timer-warning');
                } else {
                    timer2El.textContent = display;
                    timer1El.textContent = String(game.timerSetting).padStart(2, '0');
                    if (remaining <= 5) timer2El.classList.add('timer-warning'); else timer2El.classList.remove('timer-warning');
                }
                if (remaining <= 0) {
                    clearInterval(turnTimerInterval);
                    if (currentGame && currentGame.status === 'active' && ((localPlayerNumber === 1 && game.turn === 'player1') || (localPlayerNumber === 2 && game.turn === 'player2'))) {
                         switchTurn(game.turn);
                    }
                }
            };
            update();
            turnTimerInterval = setInterval(update, 500);
        }

        function showMessage(title, text, buttonText = "Close") {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            document.getElementById('message-close-btn').textContent = buttonText;
            messageModal.classList.remove('hidden');
        }

        // --- EVENT HANDLERS ---
        function handleCellClick(index) {
            if (!currentGame) return;
            const isMyTurn = (localPlayerNumber === 1 && currentGame.turn === 'player1') || (localPlayerNumber === 2 && currentGame.turn === 'player2');
            if (!isMyTurn) return;
            const isMyCell = (localPlayerNumber === 1 && currentGame.p1Cells.hasOwnProperty(index)) || (localPlayerNumber === 2 && currentGame.p2Cells.hasOwnProperty(index));
            if (isMyCell) {
                selectedCell = index;
                renderBoard(currentGame);
            }
        }

        function navigateCell(direction) {
            if (selectedCell === null) return;
            let newIndex = selectedCell;
            const row = Math.floor(selectedCell / 9), col = selectedCell % 9;
            if (direction === 'ArrowUp' && row > 0) newIndex -= 9;
            if (direction === 'ArrowDown' && row < 8) newIndex += 9;
            if (direction === 'ArrowLeft' && col > 0) newIndex -= 1;
            if (direction === 'ArrowRight' && col < 8) newIndex += 1;
            const isMyCell = (localPlayerNumber === 1 && currentGame.p1Cells.hasOwnProperty(newIndex)) || (localPlayerNumber === 2 && currentGame.p2Cells.hasOwnProperty(newIndex));
            if (isMyCell) {
                selectedCell = newIndex;
                renderBoard(currentGame);
            }
        }
        
        async function handleNumberClick(number) {
            if (selectedCell === null || !currentGame) return;
            const isMyTurn = (localPlayerNumber === 1 && currentGame.turn === 'player1') || (localPlayerNumber === 2 && currentGame.turn === 'player2');
            if (!isMyTurn) return;

            const turnBeforeMove = currentGame.turn;
            const fieldToUpdate = localPlayerNumber === 1 ? `p1Cells.${selectedCell}` : `p2Cells.${selectedCell}`;
            
            try {
                const gameRef = doc(db, `sudoku-games/${gameId}`);
                await updateDoc(gameRef, { [fieldToUpdate]: number });
                selectedCell = null;
                // Win check is handled by the onSnapshot listener after update
                // Now, switch turn immediately after the move is sent to server
                await switchTurn(turnBeforeMove);
            } catch (error) {
                console.error("Error making move:", error);
            }
        }

        // --- GAME FLOW ---
        function handleGameUpdate(gameData) {
            if (!gameData) return;
            updateUI(gameData);
            if (gameData.status === 'finished' && gameData.winner) {
                const winnerMsg = gameData.winner === `player${localPlayerNumber}` ? 'You win!' : `Player ${gameData.winner.slice(-1)} wins!`;
                updateScore(gameData.winner);
                showMessage("Game Over", winnerMsg, "Play Again");
                endGameCleanup(false); // false means don't delete doc, just detach listener
            } else if (gameData.mode === 'ai' && gameData.turn === 'player2' && gameData.status === 'active' && localPlayerNumber === 1) {
                handleAITurn(gameData);
            }
        }
        
        async function createGame(mode, timer, difficulty) {
            const { puzzle, solution, p1Cells, p2Cells } = await sudokuGenerator.generate(difficulty);
            const newGameId = Math.random().toString(36).substring(2, 8).toUpperCase();
            const gameData = {
                p1: userId, p2: mode === 'ai' ? 'AI' : null, puzzle, solution, p1Cells, p2Cells,
                turn: 'player1', timerSetting: parseInt(timer), turnEndTime: Date.now() + parseInt(timer) * 1000,
                status: mode === 'ai' ? 'active' : 'waiting', winner: null, createdAt: Date.now(), difficulty: difficulty, mode: mode,
            };
            try {
                const gameRef = doc(db, `sudoku-games/${newGameId}`);
                await setDoc(gameRef, gameData);
                await joinGame(newGameId);
            } catch (error) {
                console.error("Error creating game:", error);
                showMessage("Error", "Could not create game.");
            }
        }

        async function joinGame(id) {
            if (!id) { showMessage("Error", "Please enter a Game ID."); return; }
            gameId = id.toUpperCase();
            const gameRef = doc(db, `sudoku-games/${gameId}`);
            try {
                const gameSnap = await getDoc(gameRef);
                if (!gameSnap.exists()) { showMessage("Error", `Game ${gameId} not found.`); gameId = null; return; }
                let gameData = gameSnap.data();
                if (gameData.p1 === userId) localPlayerNumber = 1;
                else if (gameData.p2 === userId) localPlayerNumber = 2;
                else if (gameData.p2 === null) {
                    localPlayerNumber = 2;
                    await updateDoc(gameRef, { p2: userId, status: 'active', turnEndTime: Date.now() + gameData.timerSetting * 1000 });
                } else { showMessage("Error", "This game is full."); gameId = null; return; }

                setupModal.classList.add('hidden');
                gameArea.classList.remove('hidden');
                document.getElementById('score-display').classList.remove('hidden');
                document.getElementById('game-id-display').textContent = `Game ID: ${gameId}`;
                document.getElementById('copy-game-id-btn').classList.remove('hidden');

                if (unsubscribeGame) unsubscribeGame();
                unsubscribeGame = onSnapshot(gameRef, (doc) => {
                    if (doc.exists()) handleGameUpdate(doc.data());
                    else {
                        if (currentGame && currentGame.status === 'active') showMessage("Game Over", "The other player has left.", "New Game");
                        endGameCleanup();
                    }
                });
            } catch(error) {
                console.error("Error joining game:", error);
                showMessage("Error", "Could not join game.");
            }
        }

        async function switchTurn(expectedTurn) {
            if (!gameId || !currentGame || currentGame.status !== 'active') return;
            if (currentGame.turn !== expectedTurn) { console.log("Switch turn aborted, state changed."); return; }
            const newTurn = currentGame.turn === 'player1' ? 'player2' : 'player1';
            const newTurnEndTime = Date.now() + currentGame.timerSetting * 1000;
            try {
                const gameRef = doc(db, `sudoku-games/${gameId}`);
                await updateDoc(gameRef, { turn: newTurn, turnEndTime: newTurnEndTime });
            } catch (error) { console.error("Error switching turn:", error); }
        }
        
        async function checkWinCondition() {
            if (!currentGame) return false;
            let p1Complete = Object.keys(currentGame.p1Cells).every(cell => currentGame.p1Cells[cell] === currentGame.solution[cell]);
            let p2Complete = Object.keys(currentGame.p2Cells).every(cell => currentGame.p2Cells[cell] === currentGame.solution[cell]);
            let winner = null;
            if (p1Complete) winner = 'player1';
            if (p2Complete) winner = 'player2';
            if (winner) {
                try {
                    const gameRef = doc(db, `sudoku-games/${gameId}`);
                    await updateDoc(gameRef, { status: 'finished', winner: winner });
                    return true;
                } catch(e) { console.error("Error setting winner:", e); }
            }
            return false;
        }

        async function handleAITurn(gameData) {
            console.log('AI turn...');
            const aiThinkingEl = document.getElementById('ai-thinking');
            if (aiThinkingEl) aiThinkingEl.classList.remove('hidden');
            await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1500));
            
            const gameRef = doc(db, `sudoku-games/${gameId}`);
            const gameSnap = await getDoc(gameRef);
            if (!gameSnap.exists() || gameSnap.data().status !== 'active' || gameSnap.data().turn !== 'player2') {
                if (aiThinkingEl) aiThinkingEl.classList.add('hidden');
                return;
            }
            const currentData = gameSnap.data();
            const turnBeforeAITurn = currentData.turn;

            try {
                const aiMove = await getAIMove(currentData);
                if (aiMove) {
                    await updateDoc(gameRef, { [`p2Cells.${aiMove.index}`]: aiMove.value });
                    // The win check and turn switch will be handled by the snapshot listener
                } else {
                     await switchTurn(turnBeforeAITurn);
                }
            } catch (error) {
                console.error('AI turn error:', error);
                await switchTurn(turnBeforeAITurn);
            } finally {
                if (aiThinkingEl) aiThinkingEl.classList.add('hidden');
            }
        }

        function endGameCleanup(deleteGameDoc = true) {
            if (unsubscribeGame) unsubscribeGame();
            unsubscribeGame = null;
            clearInterval(turnTimerInterval);
            if (deleteGameDoc && gameId) {
                const gameRef = doc(db, `sudoku-games/${gameId}`);
                deleteDoc(gameRef).catch(e => console.error("Error deleting game doc:", e));
            }
            gameId = null;
            currentGame = null;
            localPlayerNumber = null;
            selectedCell = null;
            gameArea.classList.add('hidden');
            document.getElementById('score-display').classList.add('hidden');
            setupModal.classList.remove('hidden');
        }

        // --- INITIALIZATION ---
        function init() {
            loadScores();
            if (!firebaseConfig.apiKey || firebaseConfig.apiKey.includes("PASTE")) {
                showMessage("Configuration Error", "Firebase is not configured.");
                return;
            }
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, user => { if (user) userId = user.uid; });

            (async () => {
                try {
                     await signInAnonymously(auth);
                } catch (error) {
                     console.error("Anonymous sign-in failed:", error);
                     showMessage("Authentication Error", "Could not connect to the server.");
                }
            })();

            let selectedDifficulty = 'medium';
            const difficultyButtons = document.querySelectorAll('.difficulty-btn');
            difficultyButtons.forEach(btn => btn.addEventListener('click', () => {
                difficultyButtons.forEach(b => b.classList.replace('bg-blue-500', 'bg-gray-200'));
                btn.classList.replace('bg-gray-200', 'bg-blue-500');
                selectedDifficulty = btn.dataset.difficulty;
            }));

            const modeButtons = document.querySelectorAll('.mode-btn');
            modeButtons.forEach(btn => btn.addEventListener('click', () => {
                 modeButtons.forEach(b => b.classList.replace('bg-blue-500', 'bg-gray-200'));
                 btn.classList.replace('bg-gray-200', 'bg-blue-500');
                 document.getElementById('multiplayer-options').classList.toggle('hidden', btn.id !== 'vs-player-btn');
                 document.getElementById('start-ai-game-btn').classList.toggle('hidden', btn.id === 'vs-player-btn');
            }));

            document.getElementById('start-ai-game-btn').addEventListener('click', () => createGame('ai', document.getElementById('timer-select').value, selectedDifficulty));
            document.getElementById('create-game-btn').addEventListener('click', () => createGame('player', document.getElementById('timer-select').value, selectedDifficulty));
            document.getElementById('join-game-btn').addEventListener('click', () => joinGame(document.getElementById('join-game-id').value));
            document.getElementById('message-close-btn').addEventListener('click', () => { messageModal.classList.add('hidden'); endGameCleanup(); });
            document.getElementById('end-game-btn').addEventListener('click', () => endGameCleanup());
            document.getElementById('copy-game-id-btn').addEventListener('click', () => {
                if (gameId) navigator.clipboard.writeText(gameId).then(() => {
                    document.getElementById('copy-icon').classList.add('hidden');
                    document.getElementById('check-icon').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('copy-icon').classList.remove('hidden');
                        document.getElementById('check-icon').classList.add('hidden');
                    }, 1500);
                });
            });
            document.getElementById('reset-scores-btn').addEventListener('click', resetScores);

            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.className = "w-12 h-12 bg-white border-2 border-blue-500 text-blue-500 font-bold rounded-lg shadow-md hover:bg-blue-100 transition text-xl";
                btn.onclick = () => handleNumberClick(i);
                numberPad.appendChild(btn);
            }
            const eraseBtn = document.createElement('button');
            eraseBtn.innerHTML = `<svg class="w-6 h-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>`;
            eraseBtn.className = "w-12 h-12 bg-white border-2 border-red-500 text-red-500 font-bold rounded-lg shadow-md hover:bg-red-100 transition";
            eraseBtn.onclick = () => handleNumberClick(0);
            numberPad.appendChild(eraseBtn);

            document.addEventListener('keydown', (e) => {
                if (selectedCell === null || !currentGame) return;
                if (e.key >= '1' && e.key <= '9') handleNumberClick(parseInt(e.key));
                else if (e.key === '0' || e.key === 'Backspace' || e.key === 'Delete') handleNumberClick(0);
                else if (e.key.startsWith('Arrow')) { e.preventDefault(); navigateCell(e.key); }
            });
        }
        init();
    </script>
</body>
</html>

