<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Duel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow-y: auto;
        }
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            border: 3px solid #1f2937;
            width: 100%;
            height: 100%;
            max-width: 450px;
            max-height: 450px;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            background-color: #1f2937;
            gap: 1px;
        }
        .sudoku-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #d1d5db;
            font-size: clamp(0.8rem, 4vw, 1.25rem);
            position: relative;
            background-color: #fff;
            font-weight: 600;
        }
        /* 3x3 subgrid borders */
        /* Corrected selectors for vertical borders */
        .sudoku-cell:nth-child(9n-6),
        .sudoku-cell:nth-child(9n-3) {
            border-right: 3px solid #1f2937;
        }

        /* Corrected selectors for horizontal borders */
        .sudoku-grid > .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-grid > .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 3px solid #1f2937;
        }

        .player-cell-owner-1 { background-color: rgba(239, 68, 68, 0.1); } /* red-100 */
        .player-cell-owner-2 { background-color: rgba(59, 130, 246, 0.1); } /* blue-100 */
        
        .selected-cell {
            background-color: #fef9c3; /* yellow-100 */
            outline: 2px solid #f59e0b; /* amber-500 */
            z-index: 10;
        }
        .original-number { font-weight: 700; color: #1f2937; }
        .player-number { color: #3b82f6; }
        .incorrect-number { color: #ef4444; text-decoration: line-through; }

        .modal {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }
        .turn-indicator {
            transition: all 0.3s ease-in-out;
        }
        .timer-warning {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .cell-highlight {
            background-color: #e0f2fe !important; /* sky-100 */
        }
        .number-highlight {
            background-color: #d1fae5 !important; /* emerald-100 */
        }
        .player-number-pop {
            animation: pop-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes pop-in {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .notes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            font-size: clamp(0.5rem, 2vw, 0.7rem);
            color: #6b7280; /* gray-500 */
            line-height: 1.1;
            font-weight: 400;
            padding: 2px;
        }
        #progress1, #progress2 {
            transition: width 0.5s ease-in-out;
        }
        .ai-move-highlight {
            background-color: #a7f3d0 !important; /* emerald-200 */
            transition: background-color 0.5s ease;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-2 sm:p-4">

    <div id="app" class="w-full h-full max-w-4xl mx-auto p-2 sm:p-4 flex flex-col items-center justify-center">

            <!-- Score Display -->
            <div id="score-display" class="hidden w-full max-w-4xl mx-auto mb-4">
                <div class="bg-white rounded-lg shadow-md p-4">
                    <h3 class="text-lg font-bold text-center mb-3">Score Board</h3>
                    <div class="flex justify-between items-center">
                        <div class="text-center">
                            <div class="text-sm text-gray-600">Player 1 Wins</div>
                            <div id="p1-wins" class="text-2xl font-bold text-red-600">0</div>
                        </div>
                        <div class="text-center">
                            <div class="text-sm text-gray-600">Draws</div>
                            <div id="draws" class="text-2xl font-bold text-gray-600">0</div>
                        </div>
                        <div class="text-center">
                            <div class="text-sm text-gray-600">Player 2 Wins</div>
                            <div id="p2-wins" class="text-2xl font-bold text-blue-600">0</div>
                        </div>
                    </div>
                    <div class="mt-3 text-center">
                        <button id="reset-scores-btn" class="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition">Reset Scores</button>
                    </div>
                </div>
            </div>

        <!-- Game Area -->
        <div id="game-area" class="hidden w-full flex flex-col items-center justify-center space-y-2 sm:space-y-4">
            <!-- Player Info and Timers -->
            <div class="w-full flex flex-col md:flex-row gap-4 items-center">
                <!-- Player 1 -->
                <div id="player1-panel" class="p-4 bg-white rounded-lg shadow-md border-4 border-transparent w-full md:flex-1 order-2 md:order-1 transition-all duration-300 ease-in-out">
                    <h2 class="text-xl font-bold text-center text-red-600">Player 1 <span id="player1-id" class="text-xs text-gray-500 font-mono"></span></h2>
                    <div id="timer1" class="text-4xl font-mono font-bold text-center my-2">00</div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="progress1" class="bg-red-500 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                </div>

                <!-- Game Info -->
                <div class="text-center order-1 md:order-2">
                     <h1 class="text-2xl sm:text-3xl font-bold text-gray-700">Sudoku Duel</h1>
                     <div class="flex items-center justify-center space-x-2 mt-1">
                        <p id="game-id-display" class="font-mono text-sm text-gray-500"></p>
                        <button id="copy-game-id-btn" class="hidden p-1 bg-gray-200 rounded-md hover:bg-gray-300 transition" title="Copy Game ID">
                            <svg id="copy-icon" class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                            <svg id="check-icon" class="w-4 h-4 text-green-600 hidden" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>
                        </button>
                    </div>
                     <button id="end-game-btn" class="mt-2 px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">End Game</button>
                </div>

                <!-- Player 2 -->
                <div id="player2-panel" class="p-4 bg-white rounded-lg shadow-md border-4 border-transparent w-full md:flex-1 order-3 transition-all duration-300 ease-in-out">
                    <h2 class="text-xl font-bold text-center text-blue-600">Player 2 <span id="player2-id" class="text-xs text-gray-500 font-mono"></span></h2>
                    <div id="timer2" class="text-4xl font-mono font-bold text-center my-2">00</div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="progress2" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                    <div id="ai-thinking" class="hidden text-center mt-2">
                        <div class="inline-flex items-center text-blue-600">
                            <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600 mr-2"></div>
                            <span class="text-sm">AI is thinking...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sudoku Board -->
            <div class="bg-white p-2 sm:p-4 rounded-lg shadow-lg w-full max-w-sm sm:max-w-md mx-auto">
                <div id="sudoku-board" class="sudoku-grid">
                        <!-- Cells will be generated by JS -->
                </div>
            </div>

            <!-- Number Pad -->
            <div class="flex flex-col items-center mt-4 space-y-3 w-full max-w-sm sm:max-w-md">
                <div id="number-pad" class="flex flex-wrap justify-center gap-2">
                    <!-- Numbers 1-9 and Erase button generated by JS -->
                </div>
                <button id="pencil-btn" class="w-full max-w-[280px] px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition flex items-center justify-center space-x-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.5L14.732 3.732z"></path></svg>
                    <span>Pencil Mode</span>
                </button>
            </div>
        </div>

        <!-- Setup Modal -->
        <div id="setup-modal" class="modal fixed inset-0 flex items-center justify-center z-50">
            <div class="bg-white p-8 rounded-lg shadow-2xl w-full max-w-md text-center">
                <h1 class="text-3xl font-bold mb-6">Sudoku Duel</h1>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Game Mode</label>
                    <div class="flex justify-center space-x-2">
                        <button id="vs-ai-btn" class="mode-btn flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg">vs. AI</button>
                        <button id="vs-player-btn" class="mode-btn flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg">vs. Player</button>
                    </div>
                </div>

                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Difficulty</label>
                    <div class="flex justify-center space-x-2">
                        <button class="difficulty-btn flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg" data-difficulty="easy">Easy</button>
                        <button class="difficulty-btn flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg" data-difficulty="medium">Medium</button>
                        <button class="difficulty-btn flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg" data-difficulty="hard">Hard</button>
                    </div>
                </div>

                <div class="mb-6">
                    <label for="timer-select" class="block text-sm font-medium text-gray-700 mb-2">Turn Time (seconds)</label>
                    <select id="timer-select" class="w-full p-2 border border-gray-300 rounded-lg">
                        <option value="15">15</option>
                        <option value="30" selected>30</option>
                        <option value="45">45</option>
                        <option value="60">60</option>
                    </select>
                </div>

                <div class="mb-6">
                    <div class="bg-green-50 border border-green-200 rounded-lg p-3">
                        <div class="flex items-center">
                            <svg class="w-5 h-5 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-green-700 font-medium">AI Mode Ready</span>
                        </div>
                        <p class="text-xs text-green-600 mt-1">Gemini AI is integrated and ready to play!</p>
                        <p class="text-xs text-gray-500 mt-1">Check browser console for AI status</p>
                    </div>
                </div>
                
                <div id="multiplayer-options" class="hidden">
                    <button id="create-game-btn" class="w-full px-4 py-3 bg-green-500 text-white font-bold rounded-lg hover:bg-green-600 transition">Start Game</button>
                </div>

                <button id="start-ai-game-btn" class="w-full px-4 py-3 bg-green-500 text-white font-bold rounded-lg hover:bg-green-600 transition">Start Game</button>
            </div>
        </div>
        
        <!-- Message Modal -->
        <div id="message-modal" class="hidden modal fixed inset-0 flex items-center justify-center z-50">
             <div class="bg-white p-8 rounded-lg shadow-2xl w-full max-w-sm text-center">
                <h2 id="message-title" class="text-2xl font-bold mb-4">Game Over</h2>
                <p id="message-text" class="mb-6">Player 1 wins!</p>
                <button id="message-close-btn" class="w-full px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600">Play Again</button>
            </div>
        </div>

    </div>

    <script type="module">
        // Firebase imports removed - using standalone mode

        // --- DOM ELEMENTS ---
        const gameArea = document.getElementById('game-area');
        const setupModal = document.getElementById('setup-modal');
        const messageModal = document.getElementById('message-modal');
        const sudokuBoard = document.getElementById('sudoku-board');
        const numberPad = document.getElementById('number-pad');
        
        // --- STATE VARIABLES ---
        // Firebase variables removed - using standalone mode
        let userId = null;
        let gameId = null;
        let currentGame = null;
        let localPlayerNumber = null;
        let selectedCell = null;
        let turnTimerInterval = null;
        let isNotesMode = false;
        let isAIThinking = false;
        let unsubscribeGame = null;
        const geminiApiKey = '931e07bcc7244da89afc97fe5e5c8711';
        let scores = { p1Wins: 0, p2Wins: 0, draws: 0 };

        // --- STANDALONE MODE ---
        // No server configuration needed

        // --- GEMINI API INTEGRATION ---
        async function callGeminiAPI(prompt) {
            if (!geminiApiKey) {
                console.warn('Gemini API Key is missing. Using fallback.');
                return null;
            }
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Gemini API request failed:', errorData);
                    return null;
                }

                const data = await response.json();
                
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    return data.candidates[0].content.parts[0].text;
                }
                console.warn('Gemini API response format unexpected, using fallback');
                return null;
            } catch (error) {
                console.error('Gemini API error:', error);
                console.warn('Using fallback due to API error');
                return null;
            }
        }

        // Test Gemini API on startup
        async function testGeminiAPI() {
            try {
                const response = await callGeminiAPI("Say 'Hello, I am working!' and nothing else.");
                if (response) {
                    console.log('✅ Gemini API is working:', response);
                } else {
                    console.log('⚠️ Gemini API test failed, using fallback AI');
                }
            } catch (error) {
                console.log('⚠️ Gemini API test error:', error);
            }
        }

        async function getAIMove(gameData) {
            // Create a visual representation of the current board
            const board = Array(81).fill(0);
            for (let i = 0; i < 81; i++) {
                if (gameData.puzzle[i] !== 0) {
                    board[i] = gameData.puzzle[i];
                } else if (gameData.playerInputs[i]) {
                    board[i] = gameData.playerInputs[i].value;
                }
            }

            const prompt = `You are an expert Sudoku AI playing a competitive game. The goal is to have more correctly filled cells than your opponent when the board is full.

BOARD STATE (0 or . is empty):
${board.map((val, i) => val === 0 ? '.' : val).join('').match(/.{9}/g).join('\n')}

RULES OF THE DUEL:
- On your turn, you can fill any single empty cell.
- Your move should be a number you are confident is correct according to standard Sudoku rules (unique in its row, column, and 3x3 box).
- Only correctly placed numbers (that match the final hidden solution) will count towards your score.
- Make a strategic move to maximize your score and win the game.
- Return your move as ONLY "index:value" (e.g., "15:7").

YOUR MOVE:`;

            const response = await callGeminiAPI(prompt);
            if (response) {
                const match = response.match(/(\d+):(\d+)/);
                if (match) {
                    const index = parseInt(match[1]);
                    const value = parseInt(match[2]);
                    
                    // Validate that the move is on an empty cell
                    if (gameData.puzzle[index] === 0 && !gameData.playerInputs[index] && value >= 1 && value <= 9) {
                        return { index, value };
                    }
                }
            }
            
            // Fallback to simple AI if Gemini fails
            return getFallbackAIMove(gameData);
        }

        function getFallbackAIMove(gameData) {
            const emptyCells = [];
            for (let i = 0; i < 81; i++) {
                // A cell is empty if it's 0 in the puzzle and not in playerInputs
                if (gameData.puzzle[i] === 0 && !gameData.playerInputs[i]) {
                    emptyCells.push(i);
                }
            }

            if (emptyCells.length > 0) {
                // Pick a random empty cell
                const cellToSolve = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const correctValue = gameData.solution[cellToSolve];
                return { index: parseInt(cellToSolve), value: correctValue };
            }
            return null; // No moves left
        }

        // --- SUDOKU LOGIC ---
        const sudokuGenerator = {
            puzzles: {
                easy: [
                    {
                        puzzle: "619030048000061000200080000000340000050200000000000800005000001020000000000100000",
                        solution: "619532748834761925275489136182347590050216000000000800005000001020000000000100000"
                    },
                    {
                        puzzle: "005300000800000020070010500400005300010070006003200080060500009004000030000097000",
                        solution: "145328679839657124276419583497185362512973406683241759761532890924861375358790241"
                    },
                    {
                        puzzle: "200080300060070084030500209000105408000000000402706000301007040720040060004010003",
                        solution: "249186357163972584537564219976125438815439672432756891351697842728341965694812735"
                    }
                ],
                medium: [
                    {
                        puzzle: "000000000003600000070090200050007000000045700000100030001000068008500010090000400",
                        solution: "812753649943682175675491283154237896369845721287169435521974368438526917796318542"
                    },
                    {
                        puzzle: "020000000000600000500008070000050000000100000008000500000000040600000800010040000",
                        solution: "426731985871695234593428671234957168765184329189263547352819476647572813918346752"
                    },
                    {
                        puzzle: "100900000000006000050000084000000000027000190000000000340000070000700000000002008",
                        solution: "184975236273486915956231784615897320427352196893614570349528671562741800000002008"
                    }
                ],
                hard: [
                    {
                        puzzle: "000700000100000000000430200000000006000509000000000418000081000002000050040000300",
                        solution: "682715394195823670734436280000000006000509000000000418000081000002000050040000300"
                    },
                    {
                        puzzle: "000000000000003085001020000000507000004000100090000000500000073002010000000040009",
                        solution: "987654321246173985135928647863517294724369158591482376458296173372815469619347852"
                    },
                    {
                        puzzle: "600000000000001002070000000003000040000500000080000000000006010000050000000200003",
                        solution: "621849537348651792975327186253168947197534268486972351739486512862753491514297863"
                    }
                ]
            },
            generate: async function(difficulty = 'medium') {
                // This function for Gemini AI generation remains the same.
                // The corrected puzzles above will serve as a much better fallback.
                console.log(`Attempting to generate new '${difficulty}' puzzle with Gemini AI...`);
                
                let difficultyHint = '';
                if (difficulty === 'easy') {
                    difficultyHint = 'For an "easy" puzzle, provide many clues (e.g., 35-40). It should be solvable with basic strategies only.';
                } else if (difficulty === 'medium') {
                    difficultyHint = 'For a "medium" puzzle, provide a moderate number of clues (e.g., 28-31). It might require intermediate strategies like pointing pairs/triples.';
                } else if (difficulty === 'hard') {
                    difficultyHint = 'For a "hard" puzzle, provide few clues (e.g., 22-27) and require advanced techniques like X-Wing or Swordfish.';
                }

                const randomSeed = Math.random();
                const prompt = `Generate a completely new and random 9x9 Sudoku puzzle with a '${difficulty}' difficulty level. This request has a random seed of ${randomSeed} to ensure uniqueness. ${difficultyHint} The puzzle must have a single unique solution. Return the response as a single line of valid JSON with two keys: "puzzle" and "solution". "puzzle" must be an 81-character string with numbers 1-9 and 0 for empty cells. "solution" must be the corresponding 81-character solved string. Example: {"puzzle": "5300...", "solution": "5346..."}`;
                
                try {
                    const response = await callGeminiAPI(prompt);
                    if (response) {
                        const cleanedResponse = response.replace(/```json|```/g, '').trim();
                        const data = JSON.parse(cleanedResponse);

                        if (data.puzzle && data.solution && data.puzzle.length === 81 && data.solution.length === 81) {
                            console.log('✅ Successfully generated new puzzle from Gemini AI.');
                            const puzzle = data.puzzle.split('').map(Number);
                            const solution = data.solution.split('').map(Number);
                            return { puzzle, solution };
                        }
                    }
                    throw new Error('Invalid or no response from AI.');
                } catch (error) {
                    console.warn(`Gemini puzzle generation failed: ${error}. Using a fallback puzzle.`);
                    const puzzles = this.puzzles[difficulty];
                    const randomPuzzle = puzzles[Math.floor(Math.random() * puzzles.length)];
                    const puzzle = randomPuzzle.puzzle.split('').map(Number);
                    const solution = randomPuzzle.solution.split('').map(Number);
                    return { puzzle, solution };
                }
            }
        };

        // --- UI RENDERING ---
        function renderBoard(game) {
            sudokuBoard.innerHTML = '';

            const selectedRow = selectedCell !== null ? Math.floor(selectedCell / 9) : -1;
            const selectedCol = selectedCell !== null ? selectedCell % 9 : -1;
            const selectedBoxStartRow = selectedRow - (selectedRow % 3);
            const selectedBoxStartCol = selectedCol - (selectedCol % 3);

            let selectedValue = 0;
            if (selectedCell !== null && game.playerInputs[selectedCell] && game.playerInputs[selectedCell].value > 0) {
                selectedValue = game.playerInputs[selectedCell].value;
            } else if (selectedCell !== null && game.puzzle[selectedCell] > 0) {
                selectedValue = game.puzzle[selectedCell];
            }
            
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.classList.add('sudoku-cell', 'transition-colors');
                cell.dataset.index = i;

                let cellValue = game.puzzle[i];
                let isOriginal = cellValue !== 0;
                const playerInput = game.playerInputs[i] || { value: 0, notes: [] };

                if (playerInput.value > 0) {
                    cellValue = playerInput.value;
                    isOriginal = false;
                    if (playerInput.player === 'player1') cell.classList.add('player-cell-owner-1');
                    if (playerInput.player === 'player2') cell.classList.add('player-cell-owner-2');
                    
                    const numberSpan = document.createElement('span');
                    numberSpan.textContent = cellValue;
                    numberSpan.className = 'player-number-pop';
                    cell.appendChild(numberSpan);

                    if (isOriginal) {
                        cell.classList.add('original-number');
                    } else {
                        if (playerInput.player === 'player1') cell.classList.add('text-red-600');
                        if (playerInput.player === 'player2') cell.classList.add('text-blue-600');
                        if(cellValue !== game.solution[i]) {
                            cell.classList.add('incorrect-number');
                        }
                    }
                } else if (playerInput.notes && playerInput.notes.length > 0) {
                    const notesGrid = document.createElement('div');
                    notesGrid.className = 'notes-grid';
                    for (let n = 1; n <= 9; n++) {
                        const noteCell = document.createElement('div');
                        noteCell.textContent = playerInput.notes.includes(n) ? n : '';
                        notesGrid.appendChild(noteCell);
                    }
                    cell.appendChild(notesGrid);
                } else if (cellValue !== 0) {
                    cell.textContent = cellValue;
                    cell.classList.add('original-number');
                }

                if (!isOriginal) cell.classList.add('cursor-pointer', 'hover:bg-yellow-100');

                // Highlight row, column, and box of the selected cell
                const currentRow = Math.floor(i / 9);
                const currentCol = i % 9;
                if (selectedCell !== null && !isOriginal && (currentRow === selectedRow || currentCol === selectedCol || (Math.floor(currentRow / 3) === Math.floor(selectedRow / 3) && Math.floor(currentCol / 3) === Math.floor(selectedCol / 3)))) {
                    cell.classList.add('cell-highlight');
                }

                // Highlight all cells with the same number as the selected cell
                if (selectedValue > 0 && cellValue === selectedValue) {
                    cell.classList.add('number-highlight');
                }

                cell.addEventListener('click', () => handleCellClick(i));
                sudokuBoard.appendChild(cell);
            }
             if (selectedCell !== null) {
                const cellEl = sudokuBoard.querySelector(`[data-index='${selectedCell}']`);
                if (cellEl) cellEl.classList.add('selected-cell');
            }
        }

        function updateNumberPad(game) {
            const counts = {};
            for (let i = 1; i <= 9; i++) {
                counts[i] = 0;
            }

            // Count numbers from the initial puzzle
            for (const value of game.puzzle) {
                if (value !== 0) {
                    counts[value]++;
                }
            }

            // Count correctly placed numbers from player inputs
            for (const index in game.playerInputs) {
                const move = game.playerInputs[index];
                if (move.value > 0 && move.value === game.solution[index]) {
                    counts[move.value]++;
                }
            }

            // Update the number pad buttons
            for (let i = 1; i <= 9; i++) {
                const btn = numberPad.querySelector(`button[data-number='${i}']`);
                if (btn) {
                    btn.disabled = counts[i] >= 9;
                    btn.classList.toggle('opacity-50', counts[i] >= 9);
                    btn.classList.toggle('cursor-not-allowed', counts[i] >= 9);
                }
            }
        }

        function updateUI(game) {
            if (!game) return;
            currentGame = game;
            renderBoard(game);
            updateTimers(game);
            updateProgress(game);
            updateScoreDisplay();
            updateNumberPad(game);
            
            const p1Panel = document.getElementById('player1-panel');
            const p2Panel = document.getElementById('player2-panel');
            document.getElementById('player1-id').textContent = `(${game.p1.slice(0, 6)})`;
            document.getElementById('player2-id').textContent = game.p2 === 'AI' ? '(AI)' : (game.p2 ? `(${game.p2.slice(0, 6)})` : '...');

            p1Panel.classList.remove('border-red-500', 'border-blue-500', 'scale-105');
            p2Panel.classList.remove('border-red-500', 'border-blue-500', 'scale-105');
            
            if(game.status === 'active') {
                if (game.turn === 'player1') {
                    p1Panel.classList.add('border-red-500', 'scale-105');
                } else {
                    p2Panel.classList.add('border-blue-500', 'scale-105');
                }
            }
        }

        function updateScoreDisplay() {
            document.getElementById('p1-wins').textContent = scores.p1Wins;
            document.getElementById('p2-wins').textContent = scores.p2Wins;
            document.getElementById('draws').textContent = scores.draws;
        }

        function loadScores() {
            const savedScores = localStorage.getItem('sudoku-scores');
            if (savedScores) {
                scores = JSON.parse(savedScores);
            }
        }

        function saveScores() {
            localStorage.setItem('sudoku-scores', JSON.stringify(scores));
        }

        function updateScore(winner) {
            if (winner === 'player1') {
                scores.p1Wins++;
            } else if (winner === 'player2') {
                scores.p2Wins++;
            } else {
                scores.draws++;
            }
            saveScores();
            updateScoreDisplay();
        }

        function resetScores() {
            scores = { p1Wins: 0, p2Wins: 0, draws: 0 };
            saveScores();
            updateScoreDisplay();
        }
        
        function updateProgress(game) {
            const totalEmpty = game.puzzle.filter(c => c === 0).length;
            if (totalEmpty === 0) return;

            let p1Correct = 0;
            let p2Correct = 0;

            for (const index in game.playerInputs) {
                const move = game.playerInputs[index];
                if (move.value === game.solution[index]) {
                    if (move.player === 'player1') p1Correct++;
                    if (move.player === 'player2') p2Correct++;
                }
            }

            document.getElementById('progress1').style.width = `${(p1Correct / totalEmpty) * 100}%`;
            document.getElementById('progress2').style.width = `${(p2Correct / totalEmpty) * 100}%`;
        }

        function updateTimers(game) {
            clearInterval(turnTimerInterval);
            const timer1El = document.getElementById('timer1');
            const timer2El = document.getElementById('timer2');
            
            if (game.status !== 'active') {
                timer1El.textContent = '00';
                timer2El.textContent = '00';
                timer1El.classList.remove('timer-warning');
                timer2El.classList.remove('timer-warning');
                return;
            }

            const turnEndTime = game.turnEndTime;
            
            const updateTimerDisplay = () => {
                const remaining = Math.max(0, Math.ceil((turnEndTime - Date.now()) / 1000));
                const displayTime = String(remaining).padStart(2, '0');
                
                if (game.turn === 'player1') {
                    timer1El.textContent = displayTime;
                    timer2El.textContent = String(game.timerSetting).padStart(2, '0'); // Reset non-active timer
                    timer2El.classList.remove('timer-warning');
                    
                    if (remaining <= 5) {
                        timer1El.classList.add('timer-warning');
                    } else {
                        timer1El.classList.remove('timer-warning');
                    }
                } else {
                    timer2El.textContent = displayTime;
                    timer1El.textContent = String(game.timerSetting).padStart(2, '0'); // Reset non-active timer
                    timer1El.classList.remove('timer-warning');
                    
                    if (remaining <= 5) {
                        timer2El.classList.add('timer-warning');
                    } else {
                        timer2El.classList.remove('timer-warning');
                    }
                }
                
                if (remaining <= 0) {
                    clearInterval(turnTimerInterval);
                    // If the game is still active when the timer runs out, switch the turn.
                    // This logic is now robust for both AI and hot-seat modes.
                    if (currentGame && currentGame.status === 'active') {
                         switchTurn();
                    }
                }
            };
            
            updateTimerDisplay(); // Initial call to set the time immediately
            turnTimerInterval = setInterval(updateTimerDisplay, 500);
        }

        function showMessage(title, text, buttonText = "Close") {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            document.getElementById('message-close-btn').textContent = buttonText;
            messageModal.classList.remove('hidden');
        }

        // --- EVENT HANDLERS ---
        function handleCellClick(index) {
            if (!currentGame) return;
            
            // A cell can be selected if it's not an original, pre-filled number.
            if (currentGame.puzzle[index] === 0) {
                selectedCell = index;
            } else {
                selectedCell = null;
            }
            renderBoard(currentGame);
        }

        function navigateCell(direction) {
            if (selectedCell === null || !currentGame) return;
            
            let newIndex = selectedCell;
            const row = Math.floor(selectedCell / 9);
            const col = selectedCell % 9;
            
            switch(direction) {
                case 'ArrowUp':
                    if (row > 0) newIndex = selectedCell - 9;
                    break;
                case 'ArrowDown':
                    if (row < 8) newIndex = selectedCell + 9;
                    break;
                case 'ArrowLeft':
                    if (col > 0) newIndex = selectedCell - 1;
                    break;
                case 'ArrowRight':
                    if (col < 8) newIndex = selectedCell + 1;
                    break;
            }
            
            if (newIndex !== selectedCell) {
                if (currentGame.puzzle[newIndex] === 0) {
                    selectedCell = newIndex;
                    renderBoard(currentGame);
                }
            }
        }
        
        async function handleNumberClick(number) {
            if (selectedCell === null || !currentGame || currentGame.status !== 'active') return;
            
            const player = currentGame.turn;
            const currentInput = currentGame.playerInputs[selectedCell] || { player: null, value: 0, notes: [] };

            if (isNotesMode) {
                // Toggle notes
                currentInput.value = 0; // Clear main value if entering notes
                const noteIndex = currentInput.notes.indexOf(number);
                if (noteIndex > -1) {
                    currentInput.notes.splice(noteIndex, 1);
                } else {
                    currentInput.notes.push(number);
                    currentInput.notes.sort();
                }
                currentGame.playerInputs[selectedCell] = { ...currentInput, player };
                renderBoard(currentGame); // Re-render to show note changes without ending turn
                return;
            } else {
                currentGame.playerInputs[selectedCell] = { player, value: number, notes: [] };
            }
            
            selectedCell = null; 

            // Check if the board is full
            const totalEmptyCells = currentGame.puzzle.filter(c => c === 0).length;
            const filledCells = Object.keys(currentGame.playerInputs).length;

            if (filledCells >= totalEmptyCells) {
                // Board is full, end the game and determine winner by score
                await checkWinCondition();
            } else {
                // Board is not full, switch to the next player
                await switchTurn();
            }
        }

        // --- GAME FLOW ---
        function handleGameUpdate(gameData) {
            if (!gameData) return;

            // This function is the central point for updating the game state.
            // It was previously called from multiple places, but now it's the main driver
            // for UI updates and triggering the AI turn.
            currentGame = gameData;

            updateUI(gameData);

            // Check if game is finished
            if (gameData.status === 'finished' && gameData.winner) {
                let winnerText;
                if (gameData.winner === 'draw') {
                    winnerText = "It's a draw!";
                } else if (gameData.winner === `player${localPlayerNumber}`) {
                    winnerText = 'You win!';
                } else if (gameData.winner) {
                     winnerText = `Player ${gameData.winner === 'player1' ? '1' : '2'} wins!`;
                }
                
                updateScore(gameData.winner);
                showMessage("Game Over", winnerText, "Play Again");
                // Don't cleanup immediately, let user see the final board
                if(unsubscribeGame) unsubscribeGame();
                unsubscribeGame = null;
                clearInterval(turnTimerInterval);
                return; // Stop further processing
            }

            // If it's AI's turn to move and we are player 1
            if (gameData.mode === 'ai' && gameData.turn === 'player2' && gameData.status === 'active') {
                handleAITurn(gameData);
            }
        }
        
        async function createGame(mode, timer, difficulty) {
            try {
                console.log(`🎮 Creating ${mode} game with ${difficulty} difficulty...`);
                
                // Generate new Sudoku with AI
                const { puzzle, solution } = await sudokuGenerator.generate(difficulty);
            
                const gameData = {
                    p1: 'Player 1',
                    p2: mode === 'ai' ? 'AI' : 'Player 2',
                    puzzle,
                    solution,
                    playerInputs: {},
                    turn: 'player1',
                    timerSetting: parseInt(timer),
                    turnEndTime: Date.now() + parseInt(timer) * 1000,
                    status: 'active', // Game starts immediately for both modes
                    winner: null,
                    createdAt: Date.now(),
                    difficulty: difficulty,
                    mode: mode,
                };

                // Both AI and Player vs Player modes will start a standalone game
                startStandaloneGame(gameData);
                
            } catch (error) {
                console.error("Error creating game: ", error);
                showMessage("Error", "Could not create game. Please try again.");
            }
        }

        function startStandaloneGame(gameData) {
            gameId = 'standalone-game';
            localPlayerNumber = 1; // In hot-seat, we just need a reference, turn logic handles the rest
            currentGame = gameData;
            
            setupModal.classList.add('hidden');
            gameArea.classList.remove('hidden');
            document.getElementById('score-display').classList.remove('hidden');
            
            const gameIdDisplay = document.getElementById('game-id-display');
            if (gameData.mode === 'ai') {
                gameIdDisplay.textContent = `AI Generated ${gameData.difficulty.toUpperCase()} Puzzle`;
            } else {
                gameIdDisplay.textContent = `Local Duel (${gameData.difficulty.toUpperCase()})`;
            }
            
            updateUI(gameData);

            // Start the game timer
            updateTimers(gameData);
            
            console.log('🎮 Game started successfully!');
        }
        
        async function switchTurn() {
            if (!gameId || !currentGame) return;
            const newTurn = currentGame.turn === 'player1' ? 'player2' : 'player1';
            const newTurnEndTime = Date.now() + currentGame.timerSetting * 1000;
            
            console.log(`🔄 Switching from ${currentGame.turn} to ${newTurn}`);
            console.log(`👤 Current player: ${localPlayerNumber}, Turn: ${newTurn}`);
            
            // Update local game state and trigger the main update loop
            const updatedGame = { ...currentGame, turn: newTurn, turnEndTime: newTurnEndTime };
            handleGameUpdate(updatedGame);
        }
        
        async function checkWinCondition() {
            if (!currentGame) return;

            let p1Complete = true;
            let p2Complete = true;

            let p1Score = 0;
            let p2Score = 0;

            for (const index in currentGame.playerInputs) {
                const move = currentGame.playerInputs[index];
                if (move.value === currentGame.solution[index]) {
                    if (move.player === 'player1') {
                        p1Score++;
                    } else {
                        p2Score++;
                    }
                }
            }
            
            let winner = null;
            if (p1Score > p2Score) {
                winner = 'player1';
            } else if (p2Score > p1Score) {
                winner = 'player2';
            } else {
                winner = 'draw';
            }

            currentGame.status = 'finished';
            currentGame.winner = winner;
            handleGameUpdate(currentGame);
        }

        async function handleAITurn(gameData) {
            if (isAIThinking) return; // Prevent re-entrant calls while AI is already "thinking"
            isAIThinking = true;

            console.log('AI turn starting...');
            
            // Show AI thinking indicator
            const aiThinkingEl = document.getElementById('ai-thinking');
            if (aiThinkingEl) {
                aiThinkingEl.classList.remove('hidden');
            }
            
             // AI thinks for a bit
            setTimeout(async () => {
                // If the game was ended while the AI was "thinking", abort the turn.
                if (!currentGame || currentGame.status !== 'active') {
                    console.log('AI turn aborted as game has ended.');
                    isAIThinking = false;
                    return;
                }

                const turnBeforeAITurn = gameData.turn;
                try {
                    const aiMove = await getAIMove(gameData);
                    console.log('AI move:', aiMove);
                    
                    if (aiMove) {
                        // Create the new state with the AI's move but DON'T switch the turn yet.
                        const gameAfterAIMove = {
                            ...currentGame,
                            playerInputs: {
                                ...currentGame.playerInputs,
                                [aiMove.index]: { player: 'player2', value: aiMove.value, notes: [] }
                            }
                        };
                        
                        // Update the UI immediately to show the move. This also updates the global `currentGame` object.
                        handleGameUpdate(gameAfterAIMove);
                        
                        // Temporarily highlight the AI's move
                        const aiCellEl = sudokuBoard.querySelector(`[data-index='${aiMove.index}']`);
                        if (aiCellEl) {
                            aiCellEl.classList.add('ai-move-highlight');
                        }

                        // Wait a moment so the player can see the move.
                        await new Promise(resolve => setTimeout(resolve, 750));
                        
                        if (aiCellEl) {
                            aiCellEl.classList.remove('ai-move-highlight');
                        }

                        // Now, check for a win or switch the turn.
                        const totalEmptyCells = currentGame.puzzle.filter(c => c === 0).length;
                        const filledCells = Object.keys(currentGame.playerInputs).length;
                        if (filledCells >= totalEmptyCells) { await checkWinCondition(); } 
                        else { await switchTurn(); }
                    } else {
                        console.log('AI could not make a move, switching turn');
                        await switchTurn();
                    }
                } catch (error) {
                    console.error('AI turn error:', error);
                    await switchTurn();
                } finally {
                    // Hide AI thinking indicator
                    if (aiThinkingEl) {
                        aiThinkingEl.classList.add('hidden');
                    }
                    isAIThinking = false; // Allow the next AI turn to be triggered
                }
            }, 1500 + Math.random() * 1500); // AI "thinking" time
        }

        function endGameCleanup() {
            if(unsubscribeGame) unsubscribeGame();
            unsubscribeGame = null;
            
            clearInterval(turnTimerInterval);
            turnTimerInterval = null;
            
            // Only hide/show modals if they are in the wrong state
            if (!gameArea.classList.contains('hidden')) {
            gameArea.classList.add('hidden');
            }
            if (!document.getElementById('score-display').classList.contains('hidden')) {
                document.getElementById('score-display').classList.add('hidden');
            }
            if (setupModal.classList.contains('hidden')) {
            setupModal.classList.remove('hidden');
            }

            gameId = null;
            currentGame = null;
            localPlayerNumber = null;
            selectedCell = null;
        }

        // --- INITIALIZATION ---
        function init() {
            // Load scores
            loadScores();
            
            // Standalone mode - no server required
            console.log("🎮 Sudoku Duel - Standalone Mode Ready!");
            console.log("✅ No server connection required");
            console.log("✅ All features work offline");
            
            // Set up user for standalone mode
            userId = 'standalone-user';
            console.log("User ready for standalone play");

            // UI Setup
            let selectedDifficulty = 'medium';
            const difficultyButtons = document.querySelectorAll('.difficulty-btn');
            const modeButtons = document.querySelectorAll('.mode-btn');
            const multiplayerOptions = document.getElementById('multiplayer-options');
            const startAiGameBtn = document.getElementById('start-ai-game-btn');
            
            difficultyButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    difficultyButtons.forEach(b => {
                        b.classList.remove('bg-blue-500', 'text-white');
                        b.classList.add('bg-gray-200', 'text-gray-800');
                    });
                     btn.classList.add('bg-blue-500', 'text-white');
                    btn.classList.remove('bg-gray-200', 'text-gray-800');
                    selectedDifficulty = btn.dataset.difficulty;
                })
            });

            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    modeButtons.forEach(b => {
                        b.classList.remove('bg-blue-500', 'text-white');
                        b.classList.add('bg-gray-200', 'text-gray-800');
                    });
                    btn.classList.add('bg-blue-500', 'text-white');
                    btn.classList.remove('bg-gray-200', 'text-gray-800');

                    if (btn.id === 'vs-player-btn') {
                        multiplayerOptions.classList.remove('hidden');
                        startAiGameBtn.classList.add('hidden');
                    } else {
                        multiplayerOptions.classList.add('hidden');
                        startAiGameBtn.classList.remove('hidden');
                    }
                });
            });

            startAiGameBtn.addEventListener('click', () => {
                testGeminiAPI();
                createGame('ai', document.getElementById('timer-select').value, selectedDifficulty);
            });
            
            document.getElementById('create-game-btn').addEventListener('click', () => {
                createGame('player', document.getElementById('timer-select').value, selectedDifficulty);
            });
            
            document.getElementById('pencil-btn').addEventListener('click', () => {
                isNotesMode = !isNotesMode;
                const pencilBtn = document.getElementById('pencil-btn');
                if (isNotesMode) {
                    pencilBtn.classList.add('bg-blue-500', 'text-white');
                    pencilBtn.classList.remove('bg-gray-200', 'text-gray-800');
                } else {
                    pencilBtn.classList.remove('bg-blue-500', 'text-white');
                    pencilBtn.classList.add('bg-gray-200', 'text-gray-800');
                }
            });

            document.getElementById('message-close-btn').addEventListener('click', () => {
                messageModal.classList.add('hidden');
                endGameCleanup();
            });
            
            document.getElementById('end-game-btn').addEventListener('click', async () => {
                    endGameCleanup();
            });

            document.getElementById('copy-game-id-btn').addEventListener('click', () => {
                if (gameId && navigator.clipboard) {
                    navigator.clipboard.writeText(gameId).then(() => {
                        // Visual feedback
                        const copyIcon = document.getElementById('copy-icon');
                        const checkIcon = document.getElementById('check-icon');
                        copyIcon.classList.add('hidden');
                        checkIcon.classList.remove('hidden');
                        setTimeout(() => {
                            copyIcon.classList.remove('hidden');
                            checkIcon.classList.add('hidden');
                        }, 1500);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                    });
                }
            });

            document.getElementById('reset-scores-btn').addEventListener('click', () => {
                resetScores();
            });

            // Setup number pad
            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.dataset.number = i;
                btn.className = "w-12 h-12 bg-white border-2 border-blue-500 text-blue-500 font-bold rounded-lg shadow-md hover:bg-blue-100 transition text-xl";
                btn.onclick = () => handleNumberClick(i);
                numberPad.appendChild(btn);
            }
            const eraseBtn = document.createElement('button');
            eraseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>`;
            eraseBtn.className = "w-12 h-12 bg-white border-2 border-red-500 text-red-500 font-bold rounded-lg shadow-md hover:bg-red-100 transition";
            eraseBtn.onclick = () => handleNumberClick(0);
            numberPad.appendChild(eraseBtn);

            // Keyboard support
            document.addEventListener('keydown', (e) => {
                if (!currentGame) return;

                // Allow navigation regardless of whose turn it is
                if (e.key.startsWith('Arrow')) {
                    e.preventDefault();
                    navigateCell(e.key);
                    return;
                }

                const isMyTurn = (localPlayerNumber === 1 && currentGame.turn === 'player1') || (localPlayerNumber === 2 && currentGame.turn === 'player2');
                if (!isMyTurn) return;

                if (selectedCell !== null) {
                    if (e.key >= '1' && e.key <= '9') {
                        handleNumberClick(parseInt(e.key));
                    } else if (e.key === '0' || e.key === 'Backspace' || e.key === 'Delete') {
                        handleNumberClick(0);
                    }
                }
            });
        }

        // --- START THE APP ---
        init();
    </script>
</body>
</html>