<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Duel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow-y: auto;
        }
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            border: 3px solid #1f2937;
            width: 100%;
            height: 100%;
            max-width: 450px;
            max-height: 450px;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            background-color: #1f2937;
            gap: 1px;
        }
        .sudoku-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #d1d5db;
            font-size: clamp(0.8rem, 4vw, 1.25rem);
            position: relative;
            background-color: #fff;
            font-weight: 600;
        }
        /* 3x3 subgrid borders */
        /* Corrected selectors for vertical borders */
        .sudoku-cell:nth-child(9n-6),
        .sudoku-cell:nth-child(9n-3) {
            border-right: 3px solid #1f2937;
        }

        /* Corrected selectors for horizontal borders */
        .sudoku-grid > .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-grid > .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 3px solid #1f2937;
        }

        .player-cell-owner-1 { background-color: rgba(239, 68, 68, 0.1); } /* red-100 */
        .player-cell-owner-2 { background-color: rgba(59, 130, 246, 0.1); } /* blue-100 */
        
        .selected-cell {
            background-color: #fef9c3; /* yellow-100 */
            outline: 2px solid #f59e0b; /* amber-500 */
            z-index: 10;
        }
        .original-number { font-weight: 700; color: #1f2937; }
        .player-number { color: #3b82f6; }
        .incorrect-number { color: #ef4444; text-decoration: line-through; }

        .modal {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }
        .turn-indicator {
            transition: all 0.3s ease-in-out;
        }
        .timer-warning {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .cell-highlight {
            background-color: #fef3c7 !important;
            box-shadow: 0 0 0 2px #f59e0b;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-2 sm:p-4">

    <div id="app" class="w-full h-full max-w-4xl mx-auto p-2 sm:p-4 flex flex-col items-center justify-center">

            <!-- Score Display -->
            <div id="score-display" class="hidden w-full max-w-4xl mx-auto mb-4">
                <div class="bg-white rounded-lg shadow-md p-4">
                    <h3 class="text-lg font-bold text-center mb-3">Score Board</h3>
                    <div class="flex justify-between items-center">
                        <div class="text-center">
                            <div class="text-sm text-gray-600">Player 1 Wins</div>
                            <div id="p1-wins" class="text-2xl font-bold text-red-600">0</div>
                        </div>
                        <div class="text-center">
                            <div class="text-sm text-gray-600">Draws</div>
                            <div id="draws" class="text-2xl font-bold text-gray-600">0</div>
                        </div>
                        <div class="text-center">
                            <div class="text-sm text-gray-600">Player 2 Wins</div>
                            <div id="p2-wins" class="text-2xl font-bold text-blue-600">0</div>
                        </div>
                    </div>
                    <div class="mt-3 text-center">
                        <button id="reset-scores-btn" class="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition">Reset Scores</button>
                    </div>
                </div>
            </div>

        <!-- Game Area -->
        <div id="game-area" class="hidden w-full flex flex-col items-center justify-center space-y-2 sm:space-y-4">
            <!-- Player Info and Timers -->
            <div class="w-full flex flex-col md:flex-row gap-4 items-center">
                <!-- Player 1 -->
                <div id="player1-panel" class="p-4 bg-white rounded-lg shadow-md border-4 border-transparent w-full md:flex-1 order-2 md:order-1">
                    <h2 class="text-xl font-bold text-center text-red-600">Player 1 <span id="player1-id" class="text-xs text-gray-500 font-mono"></span></h2>
                    <div id="timer1" class="text-4xl font-mono font-bold text-center my-2">00</div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="progress1" class="bg-red-500 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                </div>

                <!-- Game Info -->
                <div class="text-center order-1 md:order-2">
                     <h1 class="text-2xl sm:text-3xl font-bold text-gray-700">Sudoku Duel</h1>
                     <div class="flex items-center justify-center space-x-2 mt-1">
                        <p id="game-id-display" class="font-mono text-sm text-gray-500"></p>
                        <button id="copy-game-id-btn" class="hidden p-1 bg-gray-200 rounded-md hover:bg-gray-300 transition" title="Copy Game ID">
                            <svg id="copy-icon" class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                            <svg id="check-icon" class="w-4 h-4 text-green-600 hidden" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>
                        </button>
                    </div>
                     <button id="end-game-btn" class="mt-2 px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">End Game</button>
                </div>

                <!-- Player 2 -->
                <div id="player2-panel" class="p-4 bg-white rounded-lg shadow-md border-4 border-transparent w-full md:flex-1 order-3">
                    <h2 class="text-xl font-bold text-center text-blue-600">Player 2 <span id="player2-id" class="text-xs text-gray-500 font-mono"></span></h2>
                    <div id="timer2" class="text-4xl font-mono font-bold text-center my-2">00</div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="progress2" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                    <div id="ai-thinking" class="hidden text-center mt-2">
                        <div class="inline-flex items-center text-blue-600">
                            <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600 mr-2"></div>
                            <span class="text-sm">AI is thinking...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sudoku Board -->
            <div class="bg-white p-2 sm:p-4 rounded-lg shadow-lg w-full max-w-sm sm:max-w-md mx-auto">
                <div id="sudoku-board" class="sudoku-grid">
                        <!-- Cells will be generated by JS -->
                </div>
            </div>

            <!-- Number Pad -->
            <div id="number-pad" class="flex flex-wrap justify-center gap-2 mt-4">
                <!-- Numbers 1-9 and Erase button generated by JS -->
            </div>
        </div>

        <!-- Setup Modal -->
        <div id="setup-modal" class="modal fixed inset-0 flex items-center justify-center z-50">
            <div class="bg-white p-8 rounded-lg shadow-2xl w-full max-w-md text-center">
                <h1 class="text-3xl font-bold mb-6">Sudoku Duel</h1>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Game Mode</label>
                    <div class="flex justify-center space-x-2">
                        <button id="vs-ai-btn" class="mode-btn flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg">vs. AI</button>
                        <button id="vs-player-btn" class="mode-btn flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg">vs. Player</button>
                    </div>
                </div>

                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Difficulty</label>
                    <div class="flex justify-center space-x-2">
                        <button class="difficulty-btn flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg" data-difficulty="easy">Easy</button>
                        <button class="difficulty-btn flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg" data-difficulty="medium">Medium</button>
                        <button class="difficulty-btn flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg" data-difficulty="hard">Hard</button>
                    </div>
                </div>

                <div class="mb-6">
                    <label for="timer-select" class="block text-sm font-medium text-gray-700 mb-2">Turn Time (seconds)</label>
                    <select id="timer-select" class="w-full p-2 border border-gray-300 rounded-lg">
                        <option value="15">15</option>
                        <option value="30" selected>30</option>
                        <option value="45">45</option>
                        <option value="60">60</option>
                    </select>
                </div>

                <div class="mb-6">
                    <div class="bg-green-50 border border-green-200 rounded-lg p-3">
                        <div class="flex items-center">
                            <svg class="w-5 h-5 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-green-700 font-medium">AI Mode Ready</span>
                        </div>
                        <p class="text-xs text-green-600 mt-1">Gemini AI is integrated and ready to play!</p>
                        <p class="text-xs text-gray-500 mt-1">Check browser console for AI status</p>
                    </div>
                </div>
                
                <div id="multiplayer-options" class="hidden">
                    <button id="create-game-btn" class="w-full px-4 py-3 bg-green-500 text-white font-bold rounded-lg hover:bg-green-600 transition">Start Game</button>
                </div>

                <button id="start-ai-game-btn" class="w-full px-4 py-3 bg-green-500 text-white font-bold rounded-lg hover:bg-green-600 transition">Start Game</button>
            </div>
        </div>
        
        <!-- Message Modal -->
        <div id="message-modal" class="hidden modal fixed inset-0 flex items-center justify-center z-50">
             <div class="bg-white p-8 rounded-lg shadow-2xl w-full max-w-sm text-center">
                <h2 id="message-title" class="text-2xl font-bold mb-4">Game Over</h2>
                <p id="message-text" class="mb-6">Player 1 wins!</p>
                <button id="message-close-btn" class="w-full px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600">Play Again</button>
            </div>
        </div>

    </div>

    <script type="module">
        // Firebase imports removed - using standalone mode

        // --- DOM ELEMENTS ---
        const gameArea = document.getElementById('game-area');
        const setupModal = document.getElementById('setup-modal');
        const messageModal = document.getElementById('message-modal');
        const sudokuBoard = document.getElementById('sudoku-board');
        const numberPad = document.getElementById('number-pad');
        
        // --- STATE VARIABLES ---
        // Firebase variables removed - using standalone mode
        let userId = null;
        let gameId = null;
        let currentGame = null;
        let localPlayerNumber = null;
        let selectedCell = null;
        let turnTimerInterval = null;
        let unsubscribeGame = null;
        const geminiApiKey = '931e07bcc7244da89afc97fe5e5c8711';
        let scores = { p1Wins: 0, p2Wins: 0, draws: 0 };

        // --- STANDALONE MODE ---
        // No server configuration needed

        // --- GEMINI API INTEGRATION ---
        async function callGeminiAPI(prompt) {
            if (!geminiApiKey) {
                console.warn('Gemini API Key is missing. Using fallback.');
                return null;
            }
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Gemini API request failed:', errorData);
                    return null;
                }

                const data = await response.json();
                
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    return data.candidates[0].content.parts[0].text;
                }
                console.warn('Gemini API response format unexpected, using fallback');
                return null;
            } catch (error) {
                console.error('Gemini API error:', error);
                console.warn('Using fallback due to API error');
                return null;
            }
        }

        // Test Gemini API on startup
        async function testGeminiAPI() {
            try {
                const response = await callGeminiAPI("Say 'Hello, I am working!' and nothing else.");
                if (response) {
                    console.log('✅ Gemini API is working:', response);
                } else {
                    console.log('⚠️ Gemini API test failed, using fallback AI');
                }
            } catch (error) {
                console.log('⚠️ Gemini API test error:', error);
            }
        }

        async function getAIMove(gameData) {
            // Create a visual representation of the current board
            const board = Array(81).fill(0);
            for (let i = 0; i < 81; i++) {
                if (gameData.puzzle[i] !== 0) {
                    board[i] = gameData.puzzle[i];
                } else if (gameData.p1Cells[i] !== undefined && gameData.p1Cells[i] !== 0) {
                    board[i] = gameData.p1Cells[i];
                } else if (gameData.p2Cells[i] !== undefined && gameData.p2Cells[i] !== 0) {
                    board[i] = gameData.p2Cells[i];
                }
            }

            const prompt = `You are an expert Sudoku AI playing a competitive game. Analyze this 9x9 Sudoku board and make the best move.

BOARD (0 = empty):
${board.map((val, i) => val === 0 ? '.' : val).join('').match(/.{9}/g).join('\n')}

YOUR ASSIGNED CELLS (Player 2): ${Object.keys(gameData.p2Cells).map(i => `Cell ${i}`).join(', ')}
OPPONENT'S CELLS (Player 1): ${Object.keys(gameData.p1Cells).map(i => `Cell ${i}`).join(', ')}

RULES:
- You can only fill YOUR assigned cells
- Fill empty cells (marked as 0) or correct wrong numbers in your cells
- Choose the most strategic move to win faster
- Return ONLY: "index:value" (e.g., "15:7")

MOVE:`;

            const response = await callGeminiAPI(prompt);
            if (response) {
                const match = response.match(/(\d+):(\d+)/);
                if (match) {
                    const index = parseInt(match[1]);
                    const value = parseInt(match[2]);
                    
                    // Validate the move
                    if (gameData.p2Cells.hasOwnProperty(index) && value >= 1 && value <= 9) {
                        return { index, value };
                    }
                }
            }
            
            // Fallback to simple AI
            return getFallbackAIMove(gameData);
        }

        function getFallbackAIMove(gameData) {
            const aiCells = Object.keys(gameData.p2Cells);
            const unsolvedAiCells = aiCells.filter(cell => 
                gameData.p2Cells[cell] === 0 || gameData.p2Cells[cell] !== gameData.solution[cell]
            );
            
            if (unsolvedAiCells.length > 0) {
                const cellToSolve = unsolvedAiCells[Math.floor(Math.random() * unsolvedAiCells.length)];
                const correctValue = gameData.solution[cellToSolve];
                return { index: parseInt(cellToSolve), value: correctValue };
            }
            return null;
        }

        // --- SUDOKU LOGIC ---
        const sudokuGenerator = {
            puzzles: {
                easy: [
                    {
                    puzzle: "603000001000400000050070080000003000000295000000800000020050030000007000400000205",
                    solution: "683924571192485367754371982875143629231695748946872153327519846518267493469738215"
                },
                    {
                        puzzle: "200080300060070084030500209000105408000000000402706000301007040720040060004010003",
                        solution: "249186357163972584537564219976125438815439672432756891351697842728341965694812735"
                    }
                ],
                medium: [
                    {
                    puzzle: "530070000600195000098000060800060003400803001700020006060000280000419005000080079",
                    solution: "534678912672195348198342567859761423426853791713924856961537284287419635345286179"
                },
                    {
                        puzzle: "000000000003600000070090200050007000000045700000100030001000068008500010090000400",
                        solution: "812753649943682175675491283154237896369845721287169435521974368438526917796318542"
                    }
                ],
                hard: [
                    {
                    puzzle: "800000000003600000070090200050007000000045700000100030001000068008500010090000400",
                    solution: "812753649943682175675491283154237896369845721287169435521974368438526917796318542"
                    },
                    {
                        puzzle: "000000000000003085001020000000507000004000100090000000500000073002010000000040009",
                        solution: "987654321246173985135928647863517294724369158591482376458296173372815469619347852"
                    }
                ]
            },
            generate: async function(difficulty = 'medium') {
                console.log(`Attempting to generate new '${difficulty}' puzzle with Gemini AI...`);
                const prompt = `Generate a new 9x9 Sudoku puzzle with a '${difficulty}' difficulty level. The puzzle must have a single unique solution. Return the response as a single line of valid JSON with two keys: "puzzle" and "solution". "puzzle" must be an 81-character string with numbers 1-9 and 0 for empty cells. "solution" must be the corresponding 81-character solved string. Example: {"puzzle": "5300...", "solution": "5346..."}`;
                
                try {
                    const response = await callGeminiAPI(prompt);
                    if (response) {
                        const cleanedResponse = response.replace(/```json|```/g, '').trim();
                        const data = JSON.parse(cleanedResponse);

                        if (data.puzzle && data.solution && data.puzzle.length === 81 && data.solution.length === 81) {
                            console.log('✅ Successfully generated new puzzle from Gemini AI.');
                            const puzzle = data.puzzle.split('').map(Number);
                            const solution = data.solution.split('').map(Number);
                            
                            const emptyCells = [];
                            for(let i=0; i<81; i++) if(puzzle[i] === 0) emptyCells.push(i);
                            emptyCells.sort(() => Math.random() - 0.5);
                            
                            const p1Cells = {};
                            const p2Cells = {};
                            emptyCells.slice(0, Math.floor(emptyCells.length / 2)).forEach(i => p1Cells[i] = 0);
                            emptyCells.slice(Math.floor(emptyCells.length / 2)).forEach(i => p2Cells[i] = 0);
                            return { puzzle, solution, p1Cells, p2Cells };
                        }
                    }
                    throw new Error('Invalid or no response from AI.');
                } catch (error) {
                    console.warn(`Gemini puzzle generation failed: ${error}. Using a fallback puzzle.`);
                    const puzzles = this.puzzles[difficulty];
                    const randomPuzzle = puzzles[Math.floor(Math.random() * puzzles.length)];
                    const puzzle = randomPuzzle.puzzle.split('').map(Number);
                    const solution = randomPuzzle.solution.split('').map(Number);
                    
                const emptyCells = [];
                for(let i=0; i<81; i++) if(puzzle[i] === 0) emptyCells.push(i);
                emptyCells.sort(() => Math.random() - 0.5);
                
                const p1Cells = {};
                const p2Cells = {};
                emptyCells.slice(0, Math.floor(emptyCells.length / 2)).forEach(i => p1Cells[i] = 0);
                emptyCells.slice(Math.floor(emptyCells.length / 2)).forEach(i => p2Cells[i] = 0);

                return { puzzle, solution, p1Cells, p2Cells };
                }
            }
        };

        // --- UI RENDERING ---
        function renderBoard(game) {
            sudokuBoard.innerHTML = '';
            let isMyTurn = (game.turn === 'player1' && localPlayerNumber === 1) || (game.turn === 'player2' && localPlayerNumber === 2);
            
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                    cell.classList.add('sudoku-cell', 'cursor-pointer', 'transition-colors');
                cell.dataset.index = i;

                const isP1Cell = game.p1Cells.hasOwnProperty(i);
                const isP2Cell = game.p2Cells.hasOwnProperty(i);

                let cellValue = game.puzzle[i];
                    let isOriginal = cellValue !== 0;
                    
                if (isP1Cell && game.p1Cells[i] !== 0) cellValue = game.p1Cells[i];
                if (isP2Cell && game.p2Cells[i] !== 0) cellValue = game.p2Cells[i];

                    if (cellValue !== 0) {
                        cell.textContent = cellValue;
                        if (isOriginal) {
                             cell.classList.add('original-number');
                        } else {
                            cell.classList.add('player-number');
                        if(cellValue !== game.solution[i]) {
                                cell.classList.add('incorrect-number');
                            }
                        }
                    }

                    if (isMyTurn) {
                        if (localPlayerNumber === 1 && isP1Cell) {
                           cell.classList.add('player-cell-owner-1', 'hover:bg-red-200');
                        } else if (localPlayerNumber === 2 && isP2Cell) {
                           cell.classList.add('player-cell-owner-2', 'hover:bg-blue-200');
                        }
                    } else {
                        if (isP1Cell) cell.classList.add('player-cell-owner-1');
                        if (isP2Cell) cell.classList.add('player-cell-owner-2');
                    }
                    
                cell.addEventListener('click', () => handleCellClick(i));
                sudokuBoard.appendChild(cell);
            }
             if (selectedCell !== null) {
                const cellEl = sudokuBoard.querySelector(`[data-index='${selectedCell}']`);
                if (cellEl) cellEl.classList.add('selected-cell');
            }
        }

        function updateUI(game) {
            if (!game) return;
            currentGame = game;
            renderBoard(game);
            updateTimers(game);
            updateProgress(game);
            updateScoreDisplay();
            
            const p1Panel = document.getElementById('player1-panel');
            const p2Panel = document.getElementById('player2-panel');
            document.getElementById('player1-id').textContent = `(${game.p1.slice(0, 6)})`;
            document.getElementById('player2-id').textContent = game.p2 === 'AI' ? '(AI)' : (game.p2 ? `(${game.p2.slice(0, 6)})` : '...');

            p1Panel.classList.remove('border-red-500', 'border-blue-500');
            p2Panel.classList.remove('border-red-500', 'border-blue-500');
            
            if(game.status === 'active') {
                if (game.turn === 'player1') {
                    p1Panel.classList.add('border-red-500');
                } else {
                    p2Panel.classList.add('border-blue-500');
                }
            }
        }

        function updateScoreDisplay() {
            document.getElementById('p1-wins').textContent = scores.p1Wins;
            document.getElementById('p2-wins').textContent = scores.p2Wins;
            document.getElementById('draws').textContent = scores.draws;
        }

        function loadScores() {
            const savedScores = localStorage.getItem('sudoku-scores');
            if (savedScores) {
                scores = JSON.parse(savedScores);
            }
        }

        function saveScores() {
            localStorage.setItem('sudoku-scores', JSON.stringify(scores));
        }

        function updateScore(winner) {
            if (winner === 'player1') {
                scores.p1Wins++;
            } else if (winner === 'player2') {
                scores.p2Wins++;
            } else {
                scores.draws++;
            }
            saveScores();
            updateScoreDisplay();
        }

        function resetScores() {
            scores = { p1Wins: 0, p2Wins: 0, draws: 0 };
            saveScores();
            updateScoreDisplay();
        }
        
        function updateProgress(game) {
            const totalP1 = Object.keys(game.p1Cells).length;
            const filledP1 = totalP1 > 0 ? Object.entries(game.p1Cells).filter(([key, value]) => value !== 0 && value === game.solution[key]).length : 0;
            document.getElementById('progress1').style.width = totalP1 > 0 ? `${(filledP1 / totalP1) * 100}%` : '0%';
            
            const totalP2 = Object.keys(game.p2Cells).length;
            const filledP2 = totalP2 > 0 ? Object.entries(game.p2Cells).filter(([key, value]) => value !== 0 && value === game.solution[key]).length : 0;
            document.getElementById('progress2').style.width = totalP2 > 0 ? `${(filledP2 / totalP2) * 100}%` : '0%';
        }

        function updateTimers(game) {
            clearInterval(turnTimerInterval);
            const timer1El = document.getElementById('timer1');
            const timer2El = document.getElementById('timer2');
            
            if (game.status !== 'active') {
                timer1El.textContent = '00';
                timer2El.textContent = '00';
                timer1El.classList.remove('timer-warning');
                timer2El.classList.remove('timer-warning');
                return;
            }

            const turnEndTime = game.turnEndTime;
            
            const updateTimerDisplay = () => {
                const remaining = Math.max(0, Math.ceil((turnEndTime - Date.now()) / 1000));
                const displayTime = String(remaining).padStart(2, '0');
                
                if (game.turn === 'player1') {
                    timer1El.textContent = displayTime;
                    timer2El.textContent = String(game.timerSetting).padStart(2, '0'); // Reset non-active timer
                    timer2El.classList.remove('timer-warning');
                    
                    if (remaining <= 5) {
                        timer1El.classList.add('timer-warning');
                    } else {
                        timer1El.classList.remove('timer-warning');
                    }
                } else {
                    timer2El.textContent = displayTime;
                    timer1El.textContent = String(game.timerSetting).padStart(2, '0'); // Reset non-active timer
                    timer1El.classList.remove('timer-warning');
                    
                    if (remaining <= 5) {
                        timer2El.classList.add('timer-warning');
                    } else {
                        timer2El.classList.remove('timer-warning');
                    }
                }
                
                if (remaining <= 0) {
                    clearInterval(turnTimerInterval);
                    // Only the player whose turn it was should trigger the switch
                    // And only if the game is still active (hasn't been won in the meantime)
                    if (currentGame && currentGame.status === 'active' && ((localPlayerNumber === 1 && game.turn === 'player1') || (localPlayerNumber === 2 && game.turn === 'player2'))) {
                         switchTurn(game.turn);
                    }
                }
            };
            
            updateTimerDisplay(); // Initial call to set the time immediately
            turnTimerInterval = setInterval(updateTimerDisplay, 500);
        }

        function showMessage(title, text, buttonText = "Close") {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            document.getElementById('message-close-btn').textContent = buttonText;
            messageModal.classList.remove('hidden');
        }

        // --- EVENT HANDLERS ---
        function handleCellClick(index) {
            if (!currentGame) return;

            const isP1Turn = currentGame.turn === 'player1';
            const isP2Turn = currentGame.turn === 'player2';
            const isP1Cell = currentGame.p1Cells.hasOwnProperty(index);
            const isP2Cell = currentGame.p2Cells.hasOwnProperty(index);

            // In AI mode, only the human player (player 1) can select cells.
            // In Player mode (hot-seat), a click is valid if it's the right turn for that cell type.
            const canSelect = (currentGame.mode === 'ai' && localPlayerNumber === 1 && isP1Turn && isP1Cell) ||
                              (currentGame.mode === 'player' && ((isP1Turn && isP1Cell) || (isP2Turn && isP2Cell)));

            if (canSelect) {
                selectedCell = index;
                renderBoard(currentGame);
            } else {
                selectedCell = null; // Deselect if it's not a valid cell to click
                renderBoard(currentGame);
            }
        }

        function navigateCell(direction) {
            if (selectedCell === null || !currentGame) return;
            
            let newIndex = selectedCell;
            const row = Math.floor(selectedCell / 9);
            const col = selectedCell % 9;
            
            switch(direction) {
                case 'ArrowUp':
                    if (row > 0) newIndex = selectedCell - 9;
                    break;
                case 'ArrowDown':
                    if (row < 8) newIndex = selectedCell + 9;
                    break;
                case 'ArrowLeft':
                    if (col > 0) newIndex = selectedCell - 1;
                    break;
                case 'ArrowRight':
                    if (col < 8) newIndex = selectedCell + 1;
                    break;
            }
            
            if (newIndex !== selectedCell) {
                const isMyCell = (localPlayerNumber === 1 && currentGame.p1Cells.hasOwnProperty(newIndex)) || (localPlayerNumber === 2 && currentGame.p2Cells.hasOwnProperty(newIndex));
                if (isMyCell) {
                    selectedCell = newIndex;
                    renderBoard(currentGame);
                }
            }
        }
        
        async function handleNumberClick(number) {
            if (selectedCell === null || !currentGame || currentGame.status !== 'active') return;
            
            const isP1Turn = currentGame.turn === 'player1';
            const isP2Turn = currentGame.turn === 'player2';

            // Determine which player is making the move based on the current turn
            if (isP1Turn) {
                currentGame.p1Cells[selectedCell] = number;
            } else if (isP2Turn) {
                currentGame.p2Cells[selectedCell] = number;
            }

            // Deselect the cell after the move.
            selectedCell = null; 

            // The logic is now:
            // 1. Check for a win with the new move.
            // 2. If no win, switch the turn.
            // 3. The switchTurn function will handle the UI update and trigger the AI if needed.

            // 3. Check if the move resulted in a win. If so, the game ends.
            // If not, the turn is switched to the other player.
            if (!await checkWinCondition()) {
                await switchTurn();
            }
        }

        // --- GAME FLOW ---
        function handleGameUpdate(gameData) {
            if (!gameData) return;

            // This function is the central point for updating the game state.
            // It was previously called from multiple places, but now it's the main driver
            // for UI updates and triggering the AI turn.
            currentGame = gameData;

            updateUI(gameData);

            // Check if game is finished
            if (gameData.status === 'finished' && gameData.winner) {
                let winnerText = 'It\'s a draw!';
                if (gameData.winner === `player${localPlayerNumber}`) {
                    winnerText = 'You win!';
                } else {
                     winnerText = `Player ${gameData.winner === 'player1' ? '1' : '2'} wins!`;
                }
                
                updateScore(gameData.winner);
                showMessage("Game Over", winnerText, "Play Again");
                // Don't cleanup immediately, let user see the final board
                if(unsubscribeGame) unsubscribeGame();
                unsubscribeGame = null;
                clearInterval(turnTimerInterval);
                return; // Stop further processing
            }

            // If it's AI's turn to move and we are player 1
            if (gameData.mode === 'ai' && gameData.turn === 'player2' && gameData.status === 'active') {
                handleAITurn(gameData);
            }
        }
        
        async function createGame(mode, timer, difficulty) {
            try {
                console.log(`🎮 Creating ${mode} game with ${difficulty} difficulty...`);
                
                // Generate new Sudoku with AI
                const { puzzle, solution, p1Cells, p2Cells } = await sudokuGenerator.generate(difficulty);
            
                const gameData = {
                    p1: 'Player 1',
                    p2: mode === 'ai' ? 'AI' : 'Player 2',
                    puzzle,
                    solution,
                    p1Cells,
                    p2Cells,
                    turn: 'player1',
                    timerSetting: parseInt(timer),
                    turnEndTime: Date.now() + parseInt(timer) * 1000,
                    status: 'active', // Game starts immediately for both modes
                    winner: null,
                    createdAt: Date.now(),
                    difficulty: difficulty,
                    mode: mode,
                };

                // Both AI and Player vs Player modes will start a standalone game
                startStandaloneGame(gameData);
                
            } catch (error) {
                console.error("Error creating game: ", error);
                showMessage("Error", "Could not create game. Please try again.");
            }
        }

        function startStandaloneGame(gameData) {
            gameId = 'standalone-game';
            localPlayerNumber = 1; // In hot-seat, we just need a reference, turn logic handles the rest
            currentGame = gameData;
            
            setupModal.classList.add('hidden');
            gameArea.classList.remove('hidden');
            document.getElementById('score-display').classList.remove('hidden');
            
            const gameIdDisplay = document.getElementById('game-id-display');
            if (gameData.mode === 'ai') {
                gameIdDisplay.textContent = `AI Generated ${gameData.difficulty.toUpperCase()} Puzzle`;
            } else {
                gameIdDisplay.textContent = `Local Duel (${gameData.difficulty.toUpperCase()})`;
            }
            
            updateUI(gameData);

            // Start the game timer
            updateTimers(gameData);
            
            console.log('🎮 Game started successfully!');
        }
        
        async function switchTurn() {
            if (!gameId || !currentGame) return;
            const newTurn = currentGame.turn === 'player1' ? 'player2' : 'player1';
            const newTurnEndTime = Date.now() + currentGame.timerSetting * 1000;
            
            console.log(`🔄 Switching from ${currentGame.turn} to ${newTurn}`);
            console.log(`👤 Current player: ${localPlayerNumber}, Turn: ${newTurn}`);
            
            // Update local game state and trigger the main update loop
            const updatedGame = { ...currentGame, turn: newTurn, turnEndTime: newTurnEndTime };
            handleGameUpdate(updatedGame);
        }
        
        async function checkWinCondition() {
            if (!currentGame) return false;
            let p1Complete = true;
            for(const cell in currentGame.p1Cells) {
                if(currentGame.p1Cells[cell] !== currentGame.solution[cell]) {
                    p1Complete = false;
                    break;
                }
            }

            let p2Complete = true;
            for(const cell in currentGame.p2Cells) {
                if(currentGame.p2Cells[cell] !== currentGame.solution[cell]) {
                    p2Complete = false;
                    break;
                }
            }
            
            let winner = null;
            if(p1Complete) winner = 'player1';
            // Use 'else if' to prevent player2 from winning if player1 just completed the board.
            // The first player to have all their cells correct wins.
            else if(p2Complete) winner = 'player2';
            if(winner) {
                // Update local game state
                currentGame.status = 'finished';
                currentGame.winner = winner;
                
                // Trigger game over
                handleGameUpdate(currentGame);
                    return true;
            }
            return false;
        }

        async function handleAITurn(gameData) {
            console.log('AI turn starting...');
            
            // Show AI thinking indicator
            const aiThinkingEl = document.getElementById('ai-thinking');
            if (aiThinkingEl) {
                aiThinkingEl.classList.remove('hidden');
            }
            
             // AI thinks for a bit
            setTimeout(async () => {
                // If the game was ended while the AI was "thinking", abort the turn.
                if (!currentGame || currentGame.status !== 'active') {
                    console.log('AI turn aborted as game has ended.');
                    return;
                }

                const turnBeforeAITurn = gameData.turn;
                try {
                    const aiMove = await getAIMove(gameData);
                    console.log('AI move:', aiMove);
                    
                    if (aiMove) {
                        // Update local game state
                        currentGame.p2Cells[aiMove.index] = aiMove.value;
                        console.log(`AI placed ${aiMove.value} in cell ${aiMove.index}`);
                        
                        // Update UI
                        updateUI(currentGame);
                        
                        // Check for win with the new move, then switch turn if no win
                    if (!await checkWinCondition()) {
                         await switchTurn();
                    }
                    } else {
                        console.log('AI could not make a move, switching turn');
                        await switchTurn();
                    }
                } catch (error) {
                    console.error('AI turn error:', error);
                    await switchTurn();
                } finally {
                    // Hide AI thinking indicator
                    if (aiThinkingEl) {
                        aiThinkingEl.classList.add('hidden');
                    }
                }
            }, 1500 + Math.random() * 1500); // AI "thinking" time
        }

        function endGameCleanup() {
            if(unsubscribeGame) unsubscribeGame();
            unsubscribeGame = null;
            
            clearInterval(turnTimerInterval);
            turnTimerInterval = null;
            
            // Only hide/show modals if they are in the wrong state
            if (!gameArea.classList.contains('hidden')) {
            gameArea.classList.add('hidden');
            }
            if (!document.getElementById('score-display').classList.contains('hidden')) {
                document.getElementById('score-display').classList.add('hidden');
            }
            if (setupModal.classList.contains('hidden')) {
            setupModal.classList.remove('hidden');
            }

            gameId = null;
            currentGame = null;
            localPlayerNumber = null;
            selectedCell = null;
        }

        // --- INITIALIZATION ---
        function init() {
            // Load scores
            loadScores();
            
            // Standalone mode - no server required
            console.log("🎮 Sudoku Duel - Standalone Mode Ready!");
            console.log("✅ No server connection required");
            console.log("✅ All features work offline");
            
            // Set up user for standalone mode
            userId = 'standalone-user';
            console.log("User ready for standalone play");

            // UI Setup
            let selectedDifficulty = 'medium';
            const difficultyButtons = document.querySelectorAll('.difficulty-btn');
            const modeButtons = document.querySelectorAll('.mode-btn');
            const multiplayerOptions = document.getElementById('multiplayer-options');
            const startAiGameBtn = document.getElementById('start-ai-game-btn');
            
            difficultyButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    difficultyButtons.forEach(b => {
                        b.classList.remove('bg-blue-500', 'text-white');
                        b.classList.add('bg-gray-200', 'text-gray-800');
                    });
                     btn.classList.add('bg-blue-500', 'text-white');
                    btn.classList.remove('bg-gray-200', 'text-gray-800');
                    selectedDifficulty = btn.dataset.difficulty;
                })
            });

            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    modeButtons.forEach(b => {
                        b.classList.remove('bg-blue-500', 'text-white');
                        b.classList.add('bg-gray-200', 'text-gray-800');
                    });
                    btn.classList.add('bg-blue-500', 'text-white');
                    btn.classList.remove('bg-gray-200', 'text-gray-800');

                    if (btn.id === 'vs-player-btn') {
                        multiplayerOptions.classList.remove('hidden');
                        startAiGameBtn.classList.add('hidden');
                    } else {
                        multiplayerOptions.classList.add('hidden');
                        startAiGameBtn.classList.remove('hidden');
                    }
                });
            });

            startAiGameBtn.addEventListener('click', () => {
                testGeminiAPI();
                createGame('ai', document.getElementById('timer-select').value, selectedDifficulty);
            });
            
            document.getElementById('create-game-btn').addEventListener('click', () => {
                createGame('player', document.getElementById('timer-select').value, selectedDifficulty);
            });
            
            document.getElementById('message-close-btn').addEventListener('click', () => {
                messageModal.classList.add('hidden');
                endGameCleanup();
            });
            
            document.getElementById('end-game-btn').addEventListener('click', async () => {
                    endGameCleanup();
            });

            document.getElementById('copy-game-id-btn').addEventListener('click', () => {
                if (gameId) {
                    const textArea = document.createElement("textarea");
                    textArea.value = gameId;
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        // Visual feedback
                        const copyIcon = document.getElementById('copy-icon');
                        const checkIcon = document.getElementById('check-icon');
                        copyIcon.classList.add('hidden');
                        checkIcon.classList.remove('hidden');
                        setTimeout(() => {
                           copyIcon.classList.remove('hidden');
                           checkIcon.classList.add('hidden');
                        }, 1500);
                    } catch (err) {
                        console.error('Failed to copy text: ', err);
                    }
                    document.body.removeChild(textArea);
                }
            });

            document.getElementById('reset-scores-btn').addEventListener('click', () => {
                resetScores();
            });

            // Setup number pad
            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.className = "w-12 h-12 bg-white border-2 border-blue-500 text-blue-500 font-bold rounded-lg shadow-md hover:bg-blue-100 transition text-xl";
                btn.onclick = () => handleNumberClick(i);
                numberPad.appendChild(btn);
            }
            const eraseBtn = document.createElement('button');
            eraseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>`;
            eraseBtn.className = "w-12 h-12 bg-white border-2 border-red-500 text-red-500 font-bold rounded-lg shadow-md hover:bg-red-100 transition";
            eraseBtn.onclick = () => handleNumberClick(0);
            numberPad.appendChild(eraseBtn);

            // Keyboard support
            document.addEventListener('keydown', (e) => {
                if (selectedCell === null || !currentGame) return;
                const isMyTurn = (localPlayerNumber === 1 && currentGame.turn === 'player1') || (localPlayerNumber === 2 && currentGame.turn === 'player2');
                if (!isMyTurn) return;

                if (e.key >= '1' && e.key <= '9') {
                    handleNumberClick(parseInt(e.key));
                } else if (e.key === '0' || e.key === 'Backspace' || e.key === 'Delete') {
                    handleNumberClick(0);
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    navigateCell(e.key);
                }
            });
        }

        // --- START THE APP ---
        init();
    </script>
</body>
</html>